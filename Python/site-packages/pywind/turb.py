#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Creat turbulence wind profile
#
# Authors: Hao BAI (hao.bai@insa-rouen.fr)
# Version: 0.0
# Date: 22/10/2018
#
# Comments:
#     - 0.0: generate .bts wind file by using TurbSim (retrieve ancient batch.py)
#     - 0.1: enable multiprocessing
#     - 0.2: create a supervising function for multiprocess
# Description:
# 
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#-----------------------------------------------------------------------------------------
#                                        MODULES
#-----------------------------------------------------------------------------------------
#============================== Modules Personnels ==============================
from tools import utils
#============================== Modules Communs ==============================
import re
import json
import time
import platform
import subprocess # call a bash command e.g. 'ls'
import multiprocessing # enable multiprocessing
from pathlib import Path


#-----------------------------------------------------------------------------------------
#                                    CLASS DEFINITION
#-----------------------------------------------------------------------------------------
class Turbulence(object):
    """docstring for TurbSim"""
    def __init__(self, seed, echo):
        self.seed = seed
        self.echo = echo
        # Get OS platform name
        self._system = {'Linux':'TurbSim_glin64', 'Darwin':'TurbSim_gdar64'}
        self._turbsimName = self._system.get(platform.system())
        # input filename
        self.filename = '{}_{}mps.inp'.format(self.seed[0], self.seed[1])
        self.logPath = Path('~/Eolien/Parameters/Python/DLC1.1/log')
        self.logPath = self.logPath.expanduser()

    def run(self, silence=False):
        self._make_copy()
        self._turbsim(silence)
    
    def _make_copy(self):
        # origine .inp file --------------------------------------------------------------
        with open(self.filename, 'r') as f:
            data = f.readlines()
            for index, line in enumerate(data):
                if 'RandSeed1' in line:
                    data[index] = self._replace(line, 'RandSeed1', self.seed[2])
        # creat new .inp file ------------------------------------------------------------
        self.filename = '{}_{}mps_{}.inp'.format(self.seed[0], self.seed[1], self.seed[2])
        with open(self.filename, 'w') as f:
            f.writelines(data)

    def _replace(self, string, keyword, value):
        position = string.find(keyword)
        substring = string[:position]
        # replace float number (e.g. 12.34; 12.; .34)
        newtime = re.sub('[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)', str(value), substring)
        newline = newtime + string[position:]
        return newline

    def _turbsim(self, silence):
        ''' Call TurbSim program
        '''
        command = '~/Eolien/FAST/{0} {1}'.format(self._turbsimName, self.filename)
        try:
            if silence:
                # print("|- Running TurbSim in silence mode ...")
                output = subprocess.check_output([command], shell=True)
            else:
                # print("|- Running TurbSim ...")
                output = subprocess.call([command], shell=True)
        except subprocess.CalledProcessError as error:
            errorMessage = error.output # works only when silence = TRUE
            wrong = True
        except Exception as e:
            raise e
        else:
            wrong = False
        # if an error occurs during execution, write output message to file
        if wrong:
            self.logPath.mkdir(exist_ok=True) # create new folder if non-exist
            filename = self.logPath.joinpath('{}.TurbSim.bug'.format(self.seed[2]))
            filename.write_bytes(errorMessage)
            utils.add_failed_seeds('TurbSim', self.seed)
            raise Exception('|- [ERROR] TurbSim has an error for simulation {}, please see report in {}'.format(self.seed, filename))

#-----------------------------------------------------------------------------------------
#                                  FUNCTION DEFINITION
#-----------------------------------------------------------------------------------------
def get_turbulence(seed, silence=False, echo=True):
    temp = Turbulence(seed=seed, echo=echo)
    temp.run(silence=silence)
    return seed

def get_turbulence_multiprocess(list_seed, silence=False, echo=False):
    print('Wind Profile Generator: TurbSim v0.2 (November 5 2018)')
    print('========== Multiprocessing Mode ==========')
    # prepare a callback function
    length = len(list_seed)
    completed = []
    def printer(seed):
        pos = list_seed.index(seed) + 1
        completed.append(seed)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] {} wind at {} m/s with seed ID {} is generated at {}:{}. '
              '{} tasks waiting to be completed ...'.format(pos, length, seed[0], seed[1],
              seed[2], hour, minute, rest))
    # begin multiprocessing
    pool = multiprocessing.Pool()
    [pool.apply_async(get_turbulence, args=(seed, silence, echo), callback=printer,
     error_callback=utils.handle_error) for seed in list_seed]
    pool.close()
    pool.join()



#-----------------------------------------------------------------------------------------
#                                     MAIN FUNCTION
#-----------------------------------------------------------------------------------------
@utils.timer
def main():
    # Load seeds
    with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'):
        with open('6seeds.json', 'r') as f:
            seeds = json.loads(f.read())
    liste = [s for s in seeds if s[0] == "NTM"]
    seeds = liste

    # get_turbulence(seeds[0])
    get_turbulence_multiprocess(seeds[:2])



#-----------------------------------------------------------------------------------------
#                                      RUNNING TEST
#-----------------------------------------------------------------------------------------
if __name__ == '__main__':
        main()
