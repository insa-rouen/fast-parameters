#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# A useful statistic toolbox
#
#
# Authors: Hao BAI
# Date: 24/01/2019
#
# Version:
#   - 0.0: Fit the continuous data by several distributions
#
# Comments:
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


#!------------------------------------------------------------------------------
#!                                       MODULES
#!------------------------------------------------------------------------------
#*============================== Modules Personnels ============================
# from tools import utils
# from pygraph import chart
#*============================== Modules Communs ==============================
from matplotlib import pyplot as plt
# from matplotlib.ticker import PercentFormatter
# from scipy import stats as scistats
# from pathlib import Path
# import matplotlib.mlab as mlab
# import scipy
import scipy.stats
import json
from scipy.stats._continuous_distns import _distn_names as DIST_NAMES
# import math
import numpy as np
# import collections
# import statistics as pystats
import warnings


#!------------------------------------------------------------------------------
#!                                   CLASS DEFINITION
#!------------------------------------------------------------------------------
class Damage(object):
    """ Find extrema in FAST output file
        Attributes:
                      
        Methods:
        
    """
    def __init__(self, filebase, echo):
        pass

class Analysis(object):
    """ Cross wind speed study
    """
    def __init__(self, seeds, folder, echo):
        pass

    #!    vvvvvvvvvvvvvvvvvvvvvvvvv Pre-processing vvvvvvvvvvvvvvvvvvvvvvvvv
    def run(self):
        print('Post-processing: Analysis of fatigue damage v0.2 (25 November 2018)')
        print('|- Loading file ...')
        self._load()
        print('|- Calculating damage on spot for all wind speeds ...')
        self._damageOnSpot()
        print('|- Calculating mean damage for all wind speeds ...')
        self._meanDamageForAllSpeeds()

    def _load(self):
        pass



#!------------------------------------------------------------------------------
#!                                 FUNCTION DEFINITION
#!------------------------------------------------------------------------------
def fit(sample, distribution_name, echo=True):
    """ Return Maximum Likelihood Estimate (MLE) for distribution parameters
        INPUT
            sample: observations to be fitted [array_like]
            distribution_name: name of a continuous distribution [string]
        OUTPUT
            param: shape parameters (if applicable), followed by location
                   and scale parameters [tuple of floats]
    """
    dist = getattr(scipy.stats, distribution_name)
    param = dist.fit(sample)
    res = scipy.stats.kstest(sample, distribution_name, args=param)
    if echo:
        print(" |- {} : D = {}, p-value = {}".format(distribution_name,
                res[0], res[1]))
    return [[distribution_name, dist, param, res[0], res[1]], ]

def bestfit(sample, alpha=0.01, alert= "error", plotCDF=False, echo=True):
    """ Find the best fit distribution by using Kolmogorovâ€“Smirnov test
        alpha: statistical significance (a percentile used to reject the null 
               hypothesis) [float]
    """   
    # available distributions
    if "levy_stable" in DIST_NAMES:
        DIST_NAMES.remove("levy_stable",)
        DIST_NAMES.remove("ksone")
        DIST_NAMES.remove("kstwo")

    # find valid distributions
    dist_valid = []
    dist_invalid = []
    for (ind, dist_name) in enumerate(DIST_NAMES):
        dist = getattr(scipy.stats, dist_name)
        with warnings.catch_warnings():
            warnings.filterwarnings("error")
            # warnings.simplefilter("error", RuntimeWarning)
            try:
                param = dist.fit(sample)
            except Warning as w:
                pass
            except Exception as e:
                print("[ERROR] {} distribution occurs an error during fitting: "
                      .format(dist_name))
                raise e
            else:
                res = scipy.stats.kstest(sample, dist_name, args=param)
                if res[1] >= alpha:
                    dist_valid.append([dist_name, dist, param, res[0], res[1]])
                    if echo:
                        print(" |- {} : D = {}, p-value = {}".format(dist_name,
                              res[0], res[1]))
                else:
                    dist_invalid.append([dist_name, dist, param, res[0], res[1]]                   )
            
    if dist_valid == []:
        if alert == "error":
            raise Exception("[ERROR] Can't find any distribution to fit the "
                            "observations !")
        elif alert == "warn":
            print(" |- [WARNING] Can't find any distribution to fit the "
                  "observations ! The one with the minimum distance in K-S test"
                  " is chosed ")
            dist_invalid.sort(key=lambda x: x[-2])
            dist_valid = [dist_invalid[0],]
            dist_name = dist_valid[0][0]
            D = dist_valid[0][-2]
            p = dist_valid[0][-1]
            print(" |- {}: D={:.3f}, p-value={:.3f}".format(dist_name, D, p))
    else:
        dist_valid.sort(key=lambda x: x[-2])
    # plot CDF of all valid distributions
    if plotCDF:
        fig, axis = plt.subplots()
        axis.hist(sample, bins=len(sample), histtype="stepfilled",
                  cumulative=True, density=True, alpha=0.6)  # ECDF
        # axis.hist(sample, bins=int((len(sample))/2), histtype="step",
        #           density=True)
        # plt.show()
        x = np.linspace(min(sample), max(sample), num=len(sample))
        for (dist_name, dist, param, D, p) in dist_valid:
            cdf = dist.cdf(x, *param[:-2], loc=param[-2], scale=param[-1])
            axis.plot(x, cdf, label="{}: D={:.3f}, p-value={:.3f}".format(
                      dist_name, D, p))
        #     pdf = dist.pdf(x, *param[:-2], loc=param[-2], scale=param[-1]) * 1000
        #     axis.plot(x, pdf)
        axis.legend()
        plt.show()
    return dist_valid


#!------------------------------------------------------------------------------
#!                                    MAIN FUNCTION
#!------------------------------------------------------------------------------
def main():
    with open("data.json") as f:
        sample = json.loads(f.read())

    param = fit(sample, "lognorm")
    bestfit(sample, plotCDF=True)
    res = np.quantile(sample, [0.25, 0.75], interpolation="midpoint")
    print(res)
    sample.sort()
    print((sample[249]+sample[250])/2)
    print((sample[749]+sample[750])/2)
    # res = np.quantile(sample, [0.25, 0.75])
    # print(res)

#!------------------------------------------------------------------------------
#!                                     RUNNING TEST
#!------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
