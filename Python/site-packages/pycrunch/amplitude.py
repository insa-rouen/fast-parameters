#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Seek peak and valley value in time series data and calculate amplitude
#
#
# Authors: Hao BAI
# Date: 17/10/2018
#
# Version:
#   - 0.0: Initial version
#   - 0.1: Change codes to make a site-package
#   - 0.2: Enable possibility of multiprocessing
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import csv
import numpy
import collections
import multiprocessing
from scipy import signal



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class PeakValleyFinder(object):
    ''' Find extrema in FAST output file
        Attributes:
            filebase: basename of .out file (i.e. name without extension) [str]
            header: line number that contains column's name in input file [int]
            datarow: line number that contains the first row of data in input file [int]
            startline: begin writting results from this row in output file [int]
            channels: channel names that will be used for searching [list]            
        Methods:
            find(): search peak/valley for a given channel name
            run(): batch profile for finding processing
    '''
    def __init__(self, filebase, header, datarow, startline, channels, peak, valley, echo):
        self.filebase = filebase
        self.header = header
        self.datarow = datarow
        self.startline = startline
        self.channels = channels
        self.peak = peak
        self.valley = valley
        self.dataInput = None

        self.run(echo)

    def run(self, echo):
        print("Extrema Finder v0.2 (October 17 2018)")
        if echo: print("|- Importing "+self.filebase+" ...")
        self.dataInput = utils.readcsv(filename=self.filebase+'.out', header=self.header,
                                       datarow=self.datarow, echo=echo)
        # searching peak/valley upon each channel
        for para in self.channels:
            if echo: print("|- Searching local maximum/minimum of {}...".format(para),
                           end="")
            dataOutput = self.find(para)
            if echo: print(" Done !")
            self.save(para, dataOutput)
        print("|- The peak and valley of channel {} in {} are exported !".format(
              self.channels, self.filebase))

    def find(self, channelname):
        ''' Searching peak and/or valley values
            Input:
                peak: True/False to find peak value (i.e. local maximum) [boolean]
                valley: True/False to find valley value (i.e. local minimum) [boolean]
        '''
        dataOutput = collections.deque()
        timeline = numpy.array(self.dataInput.get(1)['Records'])
        # check whether the channel is containted in input data
        if channelname in self.dataInput.data.keys():
            data = numpy.array(self.dataInput.data.get(channelname)['Records'])
            if self.peak: # find maxima
                maxima = signal.argrelextrema(data, numpy.greater_equal, order=10)
                result = list(data[maxima[0]])
                timestep = list(timeline[maxima[0]])
                for i in range(len(result)):
                    dataOutput.append( {'Time':"{:^10}".format(timestep[i]),
                                        'Peak/Valley':"{:^10.3E}".format(result[i])} )
            if self.valley: # find minima
                minima = signal.argrelextrema(data, numpy.less_equal, order=10)
                result = list(data[minima[0]])
                timestep = list(timeline[minima[0]])
                for i in range(len(result)):
                    dataOutput.append( {'Time':"{:^10}".format(timestep[i]),
                                        'Peak/Valley':"{:^10.3E}".format(result[i])} )
        else:
            raise Exception("[Error] There is no channel named {} in input data".format(
                            channelname))
        # sort output data by time in order of increasing [deque -> list]
        dataOutput = sorted(dataOutput, key=lambda x:float(x['Time']), reverse=False)
        return dataOutput

    def save(self, channelname, dataOutput):
        # Creat the output filename
        filename = self.filebase+'_'+channelname+'.ext'
        # Create the title line
        fieldnames = []
        fieldnames.append('Time')
        fieldnames.append('Peak/Valley')
        # Create the unit line
        fieldunits = {}
        fieldunits['Time'] = "{:^10}".format("(s)")
        fieldunits['Peak/Valley'] = "{:^10}".format("(-)")        
        # Save result to the file
        with open(filename, 'wt') as f:            
            for i in range(self.startline-1): # skip empty lines
                f.write("\n")
            datawriter=csv.DictWriter(f, delimiter='\t', fieldnames=fieldnames)
            datawriter.writeheader() # write channel names
            datawriter.writerow(fieldunits) # write channel units
            for row in dataOutput: # write channel values
                datawriter.writerow(row)


#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
def find_peak_valley(filebase, header, datarow, startline, channels, peak=True, 
                     valley=True, echo=True):
    temp = PeakValleyFinder(filebase, header, datarow, startline, channels, peak, 
                            valley, echo)


def find_peak_valley_multiprocess(list_filebase, header, datarow, startline, channels, 
                                  peak=True, valley=True, echo=False):
    pool = multiprocessing.Pool()
    [pool.apply_async(find_peak_valley, args=(filebase, header, datarow, startline,
                           channels, peak, valley, echo)) for filebase in list_filebase]
    pool.close()
    pool.join()



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    find_peak_valley('NTM_3mps_-1325143789', header=7, datarow=6009, startline=12,
                     channels=['Time',])

    find_peak_valley('NTM_3mps_-1325143789', 7, 6009, 12, ['Wind1VelX','Wind1VelY',])

    find_peak_valley_multiprocess(['NTM_3mps_-1325143789',], 7, 6009, 12, ['Wind1VelZ',])
    pass



#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
