#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Seek peak and valley value in time series data and calculate amplitude
#
#
# Authors: Hao BAI
# Date: 17/10/2018
#
# Version:
#   - 0.0: Initial version
#   - 0.1: Change codes to make a site-package
#   - 0.2: Enable possibility of multiprocessing
#   - 0.3: Add class for operating peak-to-peak amplitude
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import sys
import csv
import numpy
import collections
import multiprocessing
from scipy import signal



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class PeakValleyFinder(object):
    ''' Find extrema in FAST output file
        Attributes:
            filebase: basename of .out file (i.e. name without extension) [str]
            header: line number that contains column's name in input file [int]
            datarow: line number that contains the first row of data in input file [int]
            startline: begin writting results from this row in output file [int]
            channels: channel names that will be used for searching [list]            
        Methods:
            find(): search peak/valley for a given channel name
            run(): batch profile for finding processing
    '''
    def __init__(self, filebase, header, datarow, channels, peak, valley,
                 saveToFile, echo, *args, **kwargs):
        self.filebase = filebase
        self.header = header
        self.datarow = datarow
        self.channels = channels
        self.peak = peak
        self.valley = valley
        self.saveToFile = saveToFile
        if saveToFile: self.startline = kwargs.get('startline')
        self.echo = echo
        self.dataInput = None
        self.dataOutput = []

    def run(self):
        if self.echo: print("Extrema Finder v0.2 (October 17 2018)")
        if self.echo: print("|- Importing "+self.filebase+" ...")
        self.dataInput = utils.readcsv(filename=self.filebase+'.out', header=self.header,
                                       datarow=self.datarow, echo=self.echo)
        # searching peak/valley upon each channel
        for para in self.channels:
            if self.echo: print("|- Searching local maximum/minimum of {}..."
                                .format(para), end="")
            temp = self.find(para)
            if self.echo: print(" Done !")
            if self.saveToFile:
                self.save(para, temp)
            else:
                self.dataOutput.append(temp)
        print("|- The peak and valley of channel {} in {} are exported !".format(
              self.channels, self.filebase))

    def find(self, channelname):
        ''' Searching peak and/or valley values
            Input:
                peak: True/False to find peak value (i.e. local maximum) [boolean]
                valley: True/False to find valley value (i.e. local minimum) [boolean]
        '''
        dataOutput = collections.deque()
        timeline = numpy.array(self.dataInput.get(1)['Records'])
        # check whether the channel is containted in input data
        if channelname in self.dataInput.data.keys():
            data = numpy.array(self.dataInput.data.get(channelname)['Records'])
            if self.peak: # find maxima
                maxima = signal.argrelextrema(data, numpy.greater_equal, order=10)
                result = list(data[maxima[0]])
                timestep = list(timeline[maxima[0]])
                for i in range(len(result)):
                    dataOutput.append( {'Time':"{:^10}".format(timestep[i]),
                                        'Peak/Valley':"{:^10.3E}".format(result[i])} )
            if self.valley: # find minima
                minima = signal.argrelextrema(data, numpy.less_equal, order=10)
                result = list(data[minima[0]])
                timestep = list(timeline[minima[0]])
                for i in range(len(result)):
                    dataOutput.append( {'Time':"{:^10}".format(timestep[i]),
                                        'Peak/Valley':"{:^10.3E}".format(result[i])} )
        else:
            raise Exception("[Error] There is no channel named {} in input data".format(
                            channelname))
        # sort output data by time in order of increasing [deque -> list]
        dataOutput = sorted(dataOutput, key=lambda x:float(x['Time']), reverse=False)
        return dataOutput

    def save(self, channelname, dataOutput):
        # Creat the output filename
        filename = self.filebase+'_'+channelname+'.ext'
        # Create the title line
        fieldnames = []
        fieldnames.append('Time')
        fieldnames.append('Peak/Valley')
        # Create the unit line
        fieldunits = {}
        fieldunits['Time'] = "{:^10}".format("(s)")
        fieldunits['Peak/Valley'] = "{:^10}".format("(-)")        
        # Save result to the file
        with open(filename, 'wt') as f:            
            for i in range(self.startline-1): # skip empty lines
                f.write("\n")
            datawriter=csv.DictWriter(f, delimiter='\t', fieldnames=fieldnames)
            datawriter.writeheader() # write channel names
            datawriter.writerow(fieldunits) # write channel units
            for row in dataOutput: # write channel values
                datawriter.writerow(row)


class Amplitude(object):
    ''' Operate peak-to-peak amplitude
        Attributes:
            
        Methods:
            calculate_p2p_amplitude(): calculate peak-to-peak amplitude row by row in each
                                       channel
            max_p2p_amplitude(): extract the file that has the maximum peak-to-peak
                                 amplitude
    '''
    def __init__(self, filelist):
        pass

    @classmethod
    def calculate_p2p_amplitude(self, filename):
        ''' Calculate peak-to-peak amplitude between peak and valley
            Attention ! The input data should have been sorted by increasing or decreasing
            order.
            Input:
                filename: name of file to be opened [string]
        '''
        data = utils.readfwf(filename, echo=False)

        listResult = []
        for index, value in enumerate(data.get(2)['Records']):
            if index != 0:
                startTime = data.get(1)['Records'][index-1]
                endTime = data.get(1)['Records'][index]
                diffTime = round(endTime - startTime, 2)
                diffValue = round(data.get(2)['Records'][index] - data.get(2)['Records'][index-1], 4)

                result = (startTime, endTime, diffTime, diffValue)
                listResult.append(result)
        # sort result from the largest amplitude to the smallest
        listResult.sort(key=lambda x:abs(x[-1]), reverse=True)
        return listResult

    @classmethod
    def max_p2p_amplitude(self, list_filebase, channels, extension='.ext', echo=False):
        ''' Find the maximum case in each channel
            Input:
                list_filebase: a list of basenames of file [list]
                channels: a list of FAST channel names [list]
                extension: extension of file, 'ext' or 'pek' [str]
                echo: True/False to print results on screen [boolean]
        '''
        result = []
        if not isinstance(list_filebase, list):
            temp = []
            list_filebase = temp.append(list_filebase)
        for ch in channels:
            data = []
            for file in list_filebase:
                filename = file+'_'+ch+extension
                list_amplitude = self.calculate_p2p_amplitude(filename)
                data.append( {'File':file, ch:list_amplitude[0]} )
            # find the maximum case for the current channel
            data.sort(key=lambda x:abs(x[ch][-1]), reverse=True)
            result.append(data[0])
        # show results in terminal
        if echo:
            for elem in result:
                print(elem)
        return result

    @classmethod
    def print(self, list_results, channels, fileOutput=None, comment=""):
        ''' Save maximum amplitude for the given channels in file
            Input:
                list_results: a list that contains all results coming from
                              max_p2p_amplitude() [list]
                channels: a list of FAST channel names [list]
                fileOutput: filename of output file. If not given, print to screen [str]
        '''
        # classify results in different group
        allToPrint = {}
        for ch in channels:
            temp = []
            for elem in list_results:
                if ch in elem: temp.append(elem)
            allToPrint[ch] = temp
        # detect whether print to screen or save to file
        if fileOutput is not None:
            originStdout = sys.stdout
            sys.stdout = open(fileOutput, 'w')
        # print/save contents
        if len(allToPrint[channels[0]]) == 1: # if only 1 mean wind speed is studied
            print(" ===== {} =====".format(comment))
            print(("Channel\tStart time (s)\tEnd time (s)\tDurantion(s)\t"
                   "Peak-to-peak amplitude\tFile"))
            for ch in channels:
                print(ch, end="\t")
                for i in allToPrint[ch][0][ch]:
                    print(i, end="\t")
                print(allToPrint[ch][0]['File'])
            print("\n")
        else: # case of crossing mean wind speed study, for example DLC1.3
            for ch in channels:
                print(" ===== {} =====".format(ch))
                print(("Start time (s)\tEnd time (s)\tDurantion(s)\t"
                       "Peak-to-peak amplitude\tFile"))
                for elem in allToPrint[ch]:
                    for i in elem[ch]:
                        print(i, end="\t")
                    print(elem['File'])
                print("\n")
        # change standard output back to screen if activated
        if fileOutput is not None:
            sys.stdout = originStdout
        return allToPrint


#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
def find_peak_valley(filebase, header, datarow, startline, channels, peak=True, 
                     valley=True, saveToFile=True, echo=True):
    temp = PeakValleyFinder(filebase=filebase, header=header, datarow=datarow, startline=startline, channels=channels, peak=peak, valley=valley, saveToFile=saveToFile, echo=echo)
    temp.run()

def find_peak_valley_multiprocess(list_filebase, header, datarow, startline, channels, 
                                  peak=True, valley=True, saveToFile=True, echo=False):
    pool = multiprocessing.Pool()
    [pool.apply_async(find_peak_valley, args=(filebase, header, datarow,
     startline, channels, peak, valley, saveToFile, echo),
     error_callback=utils.handle_error) for filebase in list_filebase]
    pool.close()
    pool.join()



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    # find_peak_valley('NTM_3mps_-1325143789', header=7, datarow=6009, startline=12,
    #                  channels=['Time',])
    # find_peak_valley('NTM_3mps_-1325143789', 7, 6009, 12, ['Wind1VelX','Wind1VelY',])
    # find_peak_valley_multiprocess(['NTM_3mps_-1325143789', 'NTM_3mps_-1431633139'], 7,
    #                               6009, 12, ['YawBrTDxt', 'TwHt4FLxt', 'TwrBsMyt'])
    
    filelist = ['NTM_3mps_-1325143789', 'NTM_3mps_-1431633139']
    Amplitude.max_p2p_amplitude(filelist, ['YawBrTDxt', 'TwHt4FLxt', 'TwrBsMyt',], '.ext',
                                True)
    pass



#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
