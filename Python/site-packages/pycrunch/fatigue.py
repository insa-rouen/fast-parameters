#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Post-processing the results from fatigue analysis
#
#
# Authors: Hao BAI
# Date: 29/10/2018
#
# Version:
#   - 0.0: Initial version reserved for DLC1.1
#   - 0.2: Add bar chart
# Comments:
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!------------------------------------------------------------------------------
# Just for debug
try:
    import sys, IPython
    sys.excepthook = IPython.core.ultratb.ColorTB()
except:
    pass
#*============================== Modules Personnels ============================
from tools import utils
from pywind import wind
from pygraph import chart
from pycrunch import statistic as hbstats
#*============================== Modules Communs ==============================
from matplotlib import pyplot as plt
from matplotlib.ticker import PercentFormatter
from windrose import WindroseAxes, WindAxesFactory
# from scipy import stats as scistats
from pathlib import Path
import matplotlib.mlab as mlab
import scipy
import json
import math
import numpy as np
import pandas as pd
import collections
import statistics as pystats



#!------------------------------------------------------------------------------
#!                                         CLASS
#!------------------------------------------------------------------------------
class Damage(object):
    """ Find extrema in FAST output file
        Attributes:
                      
        Methods:
        
    """
    def __init__(self, filebase, echo):
        # attributes from input
        self.filebase = filebase
        self.echo = echo
        # new attributes
        self.dataInput = None
        self.maxDamage = None
        self.maxSpot = None
        # run methods
        self.load()
        self.getMax()

    def load(self):
        with open(self.filebase+'.dam', 'r') as f:
            self.dataInput = json.loads(f.read())

    def getMax(self):
        allDamages = [value['Dcumulate'] for value in self.dataInput.values()]
        self.maxDamage = max(allDamages)
        self.maxSpot = [key for (key, value) in self.dataInput.items() 
                        if value['Dcumulate'] == self.maxDamage][0]


class Analysis(object):
    """ Cross wind speed study
    """
    def __init__(self, seeds, folder, echo):
        self.seeds = seeds
        self.folder = folder
        self.echo = echo

        self.listOfSpeed = []
        self.wind = collections.OrderedDict()

        self.run()

    #!    vvvvvvvvvvvvvvvvvvvvvvvvv Pre-processing vvvvvvvvvvvvvvvvvvvvvvvvv
    def run(self):
        print('Post-processing: Analysis of fatigue damage v0.2 (25 November 2018)')
        print('|- Loading file ...')
        self._load()
        print('|- Calculating damage on spot for all wind speeds ...')
        self._damageOnSpot()
        print('|- Calculating mean damage for all wind speeds ...')
        self._meanDamageForAllSpeeds()

    def _load(self):
        # recover list of mean wind speeds
        listOfSpeed = list(set([int(s[1]) for s in self.seeds]))
        listOfSpeed.sort()
        self.listOfSpeed = [str(v) for v in listOfSpeed]
        # initiate structure of input data
        list_keys = ['TwHt1@'+str(theta) for theta in range(0, 360, 10)]
        for v in self.listOfSpeed:
            list_values = [collections.deque() for i in list_keys]
            self.wind[v] = {'InputDamageFile':collections.deque(),
                            'MaxSpots':collections.deque(),
                            'Occurence':[],
                            'MaxSpot':'',
                            'MinDamages':collections.deque(),
                            'MeanDamages':collections.deque(),
                            'MaxDamages':collections.deque(),
                            'TowerGage1':dict(zip(list_keys, list_values))
                           }
        # read data from file
        for s in self.seeds:
            d = Damage('{}/{}_{}mps_{}'.format(self.folder, s[0], s[1], s[2]), False)
            self.wind[s[1]]['InputDamageFile'].append(d)
            self.wind[s[1]]['MaxSpots'].append(d.maxSpot)
            for key in list_keys:
                self.wind[s[1]]['TowerGage1'][key].append(d.dataInput.get(key).get('Dcumulate'))
        self.dataLength = len(self.wind[s[1]]['MaxSpots'])
    
    def _damageOnSpot(self):
        for v in self.listOfSpeed:
            data = self.wind[v]['MaxSpots']
            spotNames = set(data)
            self.wind[v]['Occurence'] = [(name, data.count(name)) for name in spotNames]
            self.wind[v]['MaxSpot'] = max(self.wind[v]['Occurence'],
                                               key=lambda x:x[1])
        if self.echo:
            print('Wind speed (m/s)\tSpot\tOccurence (/{})'.format(
                                    int(len(self.seeds)/len(self.listOfSpeed))))
            for v in self.listOfSpeed:
                print('{}\t{}\t{}'.format(v, self.wind[v]['MaxSpot'][0],
                                          self.wind[v]['MaxSpot'][1]))
    
    def _meanDamageOnGage(self, speed):
        data = collections.OrderedDict()
        # initiate data structure
        for key in self.wind[speed]['InputDamageFile'][0].dataInput.keys():
            data[key] = collections.deque()
        # get damage values
        for file in self.wind[speed]['InputDamageFile']:
            for (key, value) in file.dataInput.items():
                data[key].append(value['Dcumulate'])
        # calculate mean value
        for (key, value) in data.items():
            self.wind[speed]['MinDamages'].append((key,min(value)))
            self.wind[speed]['MeanDamages'].append((key,pystats.mean(value)))
            self.wind[speed]['MaxDamages'].append((key,max(value)))

    def _meanDamageForAllSpeeds(self):
        [self._meanDamageOnGage(v) for v in self.listOfSpeed]

    #! vvvvvvvvvvvvvvvvvvvvvvvvv Distribution Fitting vvvvvvvvvvvvvvvvvvvvvvvvv
    def fitOnSpot(self, speed, spot, bins=20):
        data = collections.deque()
        data = [file.dataInput[spot]['Dcumulate']
                for file in self.wind[speed]['InputDamageFile']]
        dist_info = hbstats.bestfit(data, plotCDF=False, echo=False)
        return dist_info[0]
    
    def fitOnGage(self, speed, gage, distname=None, quantiles=(0.025, 0.25, 0.5,
                  0.75, 0.975), alert="error", saveName=True, saveMinMax=True,
                  saveSTS=True, echo=True):
        info_all = []
        dist_all = []
        data = collections.deque()
        if echo:
            if distname is None:
                print("\nSearching best distributions for fatigue damages at "
                      "wind speed {} m/s on tower gage {}:".format(speed, gage)
                     )
            else:
                print("\nFitting {} distribution over fatigue damages at "
                      "wind speed {} m/s on tower gage {}:".format(distname,
                      speed, gage))
        for theta in range(0, 360, 10):
            # find the best fitting distribution
            spot = "TwHt{}@{}".format(gage, theta)
            data = [file.dataInput[spot]['Dcumulate']
                    for file in self.wind[speed]['InputDamageFile']]
            if echo:
                print("|- fitting {} observations on {} degree ...".format(
                      len(data), theta))
            # try:
            if distname is None:
                dist_info = hbstats.bestfit(data, alert=alert, plotCDF=False,
                                            echo=echo)
            else:
                dist_info = hbstats.fit(data, distname)
            # except Exception as e:
            #     raise e
                # raise Exception("[ERROR] No suitable distribution has been "
                #                 "found for the case of {} m/s tower gage {} "
                #                 "on theta = {} degree !".format(speed, gage,
                #                 theta))
            # find quantile values of distribution
            if echo:
                print("  |- Get quantile values by {} distribution".format(
                      dist_info[0][0]))
            dist = dist_info[0][1]
            param = dist_info[0][2]
            res_dist = dist.ppf(quantiles, *param[:-2], loc=param[-2],
                                scale=param[-1])
            # find quantile values in observations
            res_obs = np.quantile(data, quantiles, interpolation="midpoint")
            if saveMinMax:
                min_obs = np.amin(data)
                max_obs = np.amax(data)
                res_obs = np.append(res_obs, (min_obs, max_obs))
            # expectation_obs = np.mean(data)
            temp = [speed, theta]
            if saveName: temp.append(dist_info[0][0])
            temp.extend(res_dist)
            temp.extend(res_obs)
            info_all.append(temp)
            # convert info from float to string
            temp_dict = {str(theta):[]}
            for dist in dist_info:
                temp = {"Name":dist[0], "Parameters":dist[-3], 
                        "D":dist[-2], "p-value":dist[-1]}
                temp_dict[str(theta)].append(temp)
            dist_all.append(temp_dict)

        title = ["Speed (m/s)", "Theta (°)", "Distribution",
                 "[Dist] Lower boundary {}%".format(quantiles[0]*100),
                 "[Dist] 1st quantile 25%",
                 "[Dist] Median 50%",
                 "[Dist] 3rd quantile 75%",
                 "[Dist] Upper boundary {}%".format(quantiles[-1]*100),
                 "[Obser] Lower boundary {}%".format(quantiles[0]*100),
                 "[Obser] 1st quantile 25%",
                 "[Obser] Median 50%",
                 "[Obser] 3rd quantile 75%",
                 "[Obser] Upper boundary {}%".format(quantiles[-1]*100),
                 "[Obser] Minimum",
                 "[Obser] Maximum",
                 "\n"
                 ]
        if not saveName: title.pop(2)
        if not saveMinMax: del title[-3:-2]
        filename = "{}@{}mps.dat".format(len(data), speed)
        with open(filename, "w") as f:
            string_title = "\t".join(title)
            f.write(string_title)
            for line in info_all:
                newline = [str(elem) for elem in line]
                string_line = "\t".join(newline)
                f.write(string_line+"\n")
        print("|- [OK] All quantile values are saved to {}".format(filename))
        
        # save fitting distribution's information
        if saveSTS:
            encode = json.dumps(dist_all, indent=4)
            filename = filename.replace(".dat", ".sts")
            with open(filename, "w") as f:
                f.write(encode)
            print("|- [OK] All distributions are saved to {}".format(filename))


    #!    vvvvvvvvvvvvvvvvvvvvvvvvv Plot Methods vvvvvvvvvvvvvvvvvvvvvvvvv
    #*   ==================== Cumulative Fatigue Damage ====================
    def plotDamageOnSpot(self, speed, spot, axisInput=None, bins=20, xlim=[],
                         normed=True):
        data = collections.deque()
        data = [file.dataInput[spot]['Dcumulate']
                           for file in self.wind[speed]['InputDamageFile']]
        if axisInput is None:
            fig, axis = plt.subplots()
        else:
            axis = axisInput
        # X-axis is normalized to its local max. damage
        if normed:
            yMax = max(data)
            data = [y/yMax for y in data]
        # Y-axis is normalized to the total number of runs
        N, bins, patches = axis.hist(data, bins=bins,
                                     weights=np.ones(len(data))/len(data))
        # Set axis properties
        axis.yaxis.set_major_formatter(PercentFormatter(1)) # convert to percentage
        axis.set_ylim(0, 1)
        if normed:
            axis.set_xlim(0, 1)
            axis.set_xticks(np.arange(0, 1.1, 0.1))
            axis.text(0.80, 0.05, 'max. = {:.2e}'.format(yMax), ha='center',
                      va='center', transform=axis.transAxes)
        else:
            axis.ticklabel_format(style='sci', scilimits=(-3,4), axis='x')
            if xlim != []:
                if len(xlim) == 2:
                    axis.set_xlim(xlim[0], xlim[1])
                if len(xlim) == 3:
                    axis.set_xticks(np.arange(xlim[0], xlim[1]+xlim[2], xlim[2]))
        # Set titles
        if axisInput is None:
            axis.set_title('Distribution of damage at wind speed {} m/s on'
                           ' section spot {}'.format(speed, spot))
            axis.set_xlabel('10-min cumulative damage')
            axis.set_ylabel('Probability')
            plt.show()
        else:
            axis.set_title('{} m/s {}°'.format(speed, spot), pad=-15)

    def plotDamageForAllSpeeds(self, bins=20, shareXaxis=False, shareYaxis=True,
                               xlim=[], normed=True, toPDF=[]):
        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis, tight_layout=False)
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            spot = self.wind[v]['MaxSpot'][0]
            self.plotDamageOnSpot(v, spot, ax, bins, xlim, normed)
        # Common axes lables
        fig.suptitle('Distribution of damage at different wind speed')
        if normed:
            fig.text(0.5, 0.03, '10-min cumulative damage (normolized to local '             'maximum)', ha='center', va='center')
        else:
            fig.text(0.5, 0.03, '10-min cumulative damage', ha='center', va='center')
        fig.text(0.02, 0.5, 'Probability', ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.10, right=0.94, top=0.94, wspace=0.14, hspace=0.14)

    def plotDamageThroughAllSpeeds(self, gage, theta, bins=20):
        # read input data
        spot = "TwHt{}@{}".format(gage, theta)
        data = [file.dataInput[spot]["Dcumulate"] * 1e9
                for speed in range(3, 27, 2)
                for file in self.wind[str(speed)]["InputDamageFile"]]
        # 
        fig, axis = plt.subplots()
        N, bins, patches = axis.hist(data, bins=bins, density=True)
        axis.set_title("Distribution of {} damages on spot {} through all wind "
                       "speed".format(len(data), spot))
        axis.set_xlabel('10-min cumulative damage')
        axis.set_ylabel('Probability')
        plt.show()

    def plotDamageOnGageInPolar(self, speed, gage='1', axisInput=None, normed=False):
        # get and sort data
        X = collections.deque()
        Y = collections.deque()
        for (key, value) in self.wind[speed]['TowerGage'+gage].items():
            theta = math.radians(float(key[6:]))
            angle = [theta for i in range(self.dataLength)]
            X.extend(angle)
            Y.extend(value)
        # normolize the average of cumulative damage by its maximum value
        if normed:
            yMax = max(Y)
            Yorigin = Y
            Y = [y/yMax for y in Y]
        # plot in polar coordinates
        if axisInput is None:
            axis = plt.subplot(111, polar=True)
        else:
            axis = axisInput
        # plot data
        axis.plot(X, Y, '.', markersize=3)
        if normed: axis.set_rlim(0, 1)
            # axis.set_rmax(1e-7)
        #*common settings of axes
        axis.set_rlabel_position(-90) # change radius labels location [degree]
        axis.set_thetagrids(range(0,360,30)) # change theta gridlines
        # if you want to change location of θ = 0°:
        # axis.set_theta_offset(math.pi / 2)
        # axis.set_theta_direction(-1)
        # if you want to change radius labels angle
        # axis.tick_params(axis='y', rotation=-60)

        if axisInput is None:
            # axis.fill(X, Y)
            axis.set_title('Distribution of damage at wind speed {} m/s on '
                           'tower gage {} ({} runs)'.format(speed, gage, self.dataLength))
            # axis.set_xlabel('Angle of θ (°)')
            plt.show()
        else:
            axis.set_title('{} m/s gage {}'.format(speed, gage), pad=-30)
        if normed:
            axis.text(1.15, 0.1, 'max. = {:.2e}'.format(yMax), ha='center',
                      va='center', transform=axis.transAxes)
        return (X, Yorigin)

    def plot3mDamageOnGageInPolar(self, speed, gage='1', axisInput=None, normed=False):
        """ Plot 3m (i.e. Min, Mean, Max) damage on tower gage
        """
        # plot in polar coordinates
        if axisInput is None:
            axis = plt.subplot(111, polar=True)
        else:
            axis = axisInput
        if normed:
            yMax = max(self.wind[speed]['MaxDamages'], key=lambda x: x[1])[1]
        # Get and sort data ----------------------------------------------------
        # all damages
        X = collections.deque()
        Y = collections.deque()
        for (key, value) in self.wind[speed]['TowerGage'+gage].items():
            theta = math.radians(float(key[6:]))
            angle = [theta for i in range(self.dataLength)]
            X.extend(angle)
            Y.extend(value)
        if normed: Y = [y/yMax for y in Y]
        axis.plot(X, Y, '.', markersize=3)
        # Min
        temp = collections.deque()
        for elem in self.wind[speed]['MinDamages']:
            if elem[0][4] == gage:
                temp.append( (math.radians(float(elem[0][6:])), elem[1]) )
        temp = list(temp)
        temp.sort()
        X = collections.deque() # decompose to vectors for plotting
        Y = collections.deque()
        for elem in temp:
            X.append(elem[0])
            Y.append(elem[1])
        X.append(X[0]) # in order to close circle in radar graph
        Y.append(Y[0])
        if normed: Y = [y/yMax for y in Y]
        axis.plot(X, Y, '-', markersize=3)
        # Mean
        temp = collections.deque()
        for elem in self.wind[speed]['MeanDamages']:
            if elem[0][4] == gage:
                temp.append( (math.radians(float(elem[0][6:])), elem[1]) )
        temp = list(temp)
        temp.sort()
        Y = collections.deque() # decompose to vectors for plotting
        for elem in temp:
            Y.append(elem[1])
        Y.append(Y[0])
        if normed: Y = [y/yMax for y in Y]
        axis.plot(X, Y, '-', markersize=3)
        # Max
        temp = collections.deque()
        for elem in self.wind[speed]['MaxDamages']:
            if elem[0][4] == gage:
                temp.append( (math.radians(float(elem[0][6:])), elem[1]) )
        temp = list(temp)
        temp.sort()
        Y = collections.deque() # decompose to vectors for plotting
        for elem in temp:
            Y.append(elem[1])
        Y.append(Y[0])
        if normed: Y = [y/yMax for y in Y]
        axis.plot(X, Y, '-', markersize=3)
        # Settings -------------------------------------------------------------
        if normed:
            axis.set_rlim(0, 1)
            axis.text(1.15, 0.1, 'max. = {:.2e}'.format(yMax), ha='center',
                      va='center', transform=axis.transAxes)
        #*common settings of axes
        axis.set_rlabel_position(-90) # change radius labels location [degree]
        axis.set_thetagrids(range(0,360,30)) # change theta gridlines
        # if you want to change location of θ = 0°:
        # axis.set_theta_offset(math.pi / 2)
        # axis.set_theta_direction(-1)
        # if you want to change radius labels angle
        # axis.tick_params(axis='y', rotation=-60)
        if axisInput is None:
            # axis.fill(X, Y)
            axis.set_title('Distribution of damage at wind speed {} m/s on '
                           'tower gage {} ({} runs)'.format(speed, gage, self.dataLength))
            # axis.set_xlabel('Angle of θ (°)')
            plt.show()
        else:
            axis.set_title('{} m/s gage {}'.format(speed, gage), pad=-30)


    def plot3mDamageOnGageInPolar_AllSpeeds(self, gage, shareXaxis=True, shareYaxis=True, normed=True, toPDF=[]):
        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis,
                        tight_layout=False, subplot_kw=dict(projection='polar'))
        axes = [axis for ax in axes for axis in ax]
        # The minor subplots
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            spot = self.wind[v]['MaxSpot'][0] # choose gage of max damage
            self.plot3mDamageOnGageInPolar(v, spot[4], ax, normed)
        # Common axes lables
        # plt.subplots_adjust(left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
        fig.suptitle('Distribution of 3M (i.e. Min, Mean, Max) damage at different wind speed ({} runs)'.format(self.dataLength))
        fig.legend(['Damage', 'Min damage', 'Mean damage', 'Max damage'])
        fig.text(0.5, 0.03, 'Perimeter: spot angle θ (°)', ha='center', va='center')
        fig.text(0.02, 0.5, 'Radius: Cumulative damage (-)'.format(self.dataLength), ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)

    def plotDamageOnGageByErrorBar(self, speed, gage, axisInput=None, xlim=[], xticks=[], normed=False):
        X = []
        Y = []
        Yerr = []
        for (key, value) in self.wind[speed]['TowerGage'+gage].items():
            theta = float(key[6:])
            if theta >= 180: theta = theta - 360
            mean = pystats.mean(value)
            sd = pystats.stdev(value)
            X.append(theta)
            Y.append(mean)
            Yerr.append(sd)
        
        # plot in polar coordinates
        if axisInput is None:
            axis = plt.subplot(111)
        else:
            axis = axisInput
        # plot data
        axis.errorbar(X, Y, yerr=Yerr, fmt='o', ecolor='g', capsize=1, capthick=1, markersize=3)
        # set axis properties
        if axisInput is None:
            title = str('Distribution of damage at wind speed {} m/s on tower '
                        'gage {} ({} runs)'.format(speed, gage, self.dataLength))
            chart.adjust(axis, title=title, loc=None, xlim=xlim, xlabel='Angle of θ (°)', ylabel='Cumulative damage (-)', seperator=False)
            plt.show()
        else:
            axis.set_title('{} m/s gage {}'.format(speed, gage), pad=-15)
            if xlim != []:
                axis.set_xlim(xlim[0], xlim[1])
            if xticks != []:
                axis.set_xticks(np.arange(xticks[0], xticks[1]+xticks[2], xticks[2]))

    def plotDamageOnGageByErrorBar_AllSpeeds(self, gage, shareXaxis=True, shareYaxis=False, xlim=[], xticks=[], normed=False, toPDF=[]):
        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis, tight_layout=False)
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            self.plotDamageOnGageByErrorBar(v, gage, ax, xlim, xticks, normed)
        # Common axes lables
        fig.suptitle('Distribution of damage at different wind speed ({} runs)'.format(self.dataLength))
        if normed:
            fig.text(0.5, 0.03, '10-min cumulative damage (normolized to local '             'maximum)', ha='center', va='center')
        else:
            fig.text(0.5, 0.03, 'Angle of θ (°)', ha='center', va='center')
            fig.text(0.02, 0.5, 'Cumulative damage (-)', ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.10, right=0.94, top=0.94, wspace=0.14, hspace=0.14)

    def plotDamageOnGageByBox(self, speed, gage, axisInput=None, xlim=[], xticks=[], normed=False):
        X = []
        Y = []
        for (key, value) in self.wind[speed]['TowerGage'+gage].items():
            theta = int(key[6:])
            if theta >= 180: theta = theta - 360
            X.append(theta)
            Y.append(value)
        a, b = X[:len(X)//2], X[len(X)//2:]
        X = b
        X.extend(a)
        a, b = Y[:len(Y)//2], Y[len(Y)//2:]
        Y = b
        Y.extend(a)
        # plot in polar coordinates
        if axisInput is None:
            axis = plt.subplot(111)
        else:
            axis = axisInput
        # plot data
        axis.boxplot(Y, labels=X, notch=True, flierprops={'color':'black', 'marker':'.'}, patch_artist=False)
        # set axis properties
        if axisInput is None:
            title = str('Distribution of damage at wind speed {} m/s on tower '
                        'gage {} ({} runs)'.format(speed, gage, self.dataLength))
            chart.adjust(axis, title=title, loc=None, xlim=xlim, xlabel='Angle of θ (°)', ylabel='Cumulative damage (-)', seperator=False)
            plt.show()
        else:
            axis.set_title('{} m/s gage {}'.format(speed, gage), pad=-15)
            axis.grid(which='major', axis='x', linestyle=':')
            axis.xaxis.set_tick_params(bottom=False, pad=-1, rotation=90,labelsize='small')
            axis.ticklabel_format(style='sci', scilimits=(-3,4), axis='y')
            if xlim != []:
                axis.set_xlim(xlim[0], xlim[1])
            if xticks != []:
                axis.set_xticks(np.arange(xticks[0], xticks[1]+xticks[2], xticks[2]))

    def plotDamageOnGageByBox_AllSpeeds(self, gage, shareXaxis=True, shareYaxis=False, xlim=[], xticks=[], normed=False, toPDF=[]):
        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis, tight_layout=False)
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            self.plotDamageOnGageByBox(v, gage, ax, xlim, xticks, normed)
        # Common axes lables
        fig.suptitle('Distribution of damage at different wind speed ({} runs)'.format(self.dataLength))
        if normed:
            fig.text(0.5, 0.03, '10-min cumulative damage (normolized to local '             'maximum)', ha='center', va='center')
        else:
            fig.text(0.5, 0.03, 'Angle of θ (°)', ha='center', va='center')
            fig.text(0.02, 0.5, 'Cumulative damage (-)', ha='center', va='center', rotation='vertical')
        
        chart.draw(fig, toPDF, left=0.06, bottom=0.10, right=0.94, top=0.94, wspace=0.14, hspace=0.14)

    #*          ==================== Max Damage ====================
    def plotMaxDamageCountsByPie(self, toPDF=[]):
        fig, axes = plt.subplots(3, 4, tight_layout=False)
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            data = sorted(self.wind[v]['Occurence'], key=lambda x:x[1], reverse=True)
            labels = []
            fracs = []
            for x in data:
                fracs.append(x[1])
                if x[1] < 0.05*self.dataLength: # don't show spots < 5%
                    labels.append('')
                else:
                    labels.append(x[0])
            ax.pie(fracs, labels=labels, autopct=lambda p:'{:.0f}'.format(p * self.dataLength / 100),)
            ax.set_title('{} m/s'.format(v), pad=-2, ha='center', va='center', fontweight='bold')
        fig.suptitle('Counts of max damage at different wind speed ({} runs)'.format(self.dataLength))
        chart.draw(fig, toPDF, left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
    
    def plotMaxDamageCountsByBar(self, gage=None, shareXaxis=True, shareYaxis=False, toPDF=[]):
        """ Bar chart: show counts of max damage spots
            INPUT
                gage: name of tower gage "TwHt*" with *=1,...,9 [str] 
        """
        # Preprocess data
        allNames = []
        for v in self.listOfSpeed:
            names = [x[0] for x in self.wind[v]['Occurence']]
            allNames.extend(names)
        allNames = list(set(allNames))
        allNames = sorted(allNames, key=lambda x: int(x.partition('@')[-1]))
        if gage is not None or gage.lower() != 'all':
            allNames = [name for name in allNames if gage in name]
            a, b = allNames[:len(allNames)//2], allNames[len(allNames)//2:]
            allNames = b
            allNames.extend(a)
        # Begin to plot
        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis, tight_layout=False)
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            data = dict(self.wind[v]['Occurence'])
            names = allNames
            values = []
            for (index, name) in enumerate(allNames):
                if name in data:
                    value = data[name]
                    values.append(value)
                else:
                    values.append(0)
            rects = ax.bar(allNames, values, color='sienna')
            ax.set_title('{} m/s'.format(v), pad=-10, ha='center', va='center', fontweight='bold')
            # Set axis properties
            ax.grid(which='major', axis='x', linestyle=':')
            ax.xaxis.set_tick_params(bottom=False, pad=-1, rotation=90,labelsize='small')
            # Add counts on top of each bar
            chart.autolabel(ax, rects, 'center', fontSize='x-small')
        # Set figure property
        if gage is not None or gage.lower() != 'all':
            fig.suptitle('Counts of max damage at different wind speed ({} runs) : Tower Gage {}'.format(self.dataLength, gage))
        else:
            fig.suptitle('Counts of max damage at different wind speed ({} runs)'.format(self.dataLength))
        chart.draw(fig, toPDF, left=0.03, bottom=0.1, right=0.97, top=0.94, wspace=0.12, hspace=0.12)

    def plotMaxDamageCountsByBar_gage1(self, shareXaxis=True, shareYaxis=False, toPDF=[]):
        self.plotMaxDamageCountsByBar(gage='TwHt1', shareXaxis=shareXaxis, shareYaxis=shareYaxis, toPDF=toPDF)

    #*          ==================== Mean Damage ====================
    def plotMeanDamageOnGage(self, speed, gage, axisInput=None, normed=True):
        # get and sort data
        temp = collections.deque()
        for elem in self.wind[speed]['MeanDamages']:
            if elem[0][4] == gage:
                temp.append( (math.radians(float(elem[0][6:])), elem[1]) )
        temp = list(temp)
        temp.sort()
        # decompose to vectors for plotting
        X = collections.deque()
        Y = collections.deque()
        for elem in temp:
            X.append(elem[0])
            Y.append(elem[1])
        X.append(X[0]) # in order to close circle in radar graph
        Y.append(Y[0])
        # normolize the average of cumulative damage by its maximum value
        if normed:
            yMax = max(Y)
            Yorigin = Y
            Y = [y/yMax for y in Y]
        # plot in polar coordinates
        if axisInput is None:
            axis = plt.subplot(111, polar=True)
        else:
            axis = axisInput
        # plot data
        axis.plot(X, Y, 'o-', markersize=3)
        if normed: axis.set_rlim(0, 1)
            # axis.set_rmax(1e-7)
        #*common settings of axes
        axis.set_rlabel_position(-90) # change radius labels location [degree]
        axis.set_thetagrids(range(0,360,30)) # change theta gridlines
        # if you want to change location of θ = 0°:
        # axis.set_theta_offset(math.pi / 2)
        # axis.set_theta_direction(-1)
        # if you want to change radius labels angle
        # axis.tick_params(axis='y', rotation=-60)
        if normed:
            axis.text(1.15, 0.1, 'max. = {:.2e}'.format(yMax), ha='center',
                      va='center', transform=axis.transAxes)
        if axisInput is None:
            # axis.fill(X, Y) # if you want to fill inside the circle
            axis.set_title('Distribution of mean damage at wind speed {} m/s on'
                           'tower gage {}'.format(speed, gage))
            # axis.set_xlabel('Angle of θ (°)')
            plt.show()
            plt.close()
        else:
            axis.set_title('{} m/s gage {}'.format(speed, gage), pad=-30)
        if normed:
            return (X, Yorigin)
        else:
            return X

    def plotMeanDamageForAllSpeeds(self, shareXaxis=False, shareYaxis=True,
                                   toPDF=[]):

        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis,
                        tight_layout=False, subplot_kw=dict(projection='polar'))
        axes = [axis for ax in axes for axis in ax]
        
        # The minor subplots
        damages = []
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            spot = self.wind[v]['MaxSpot'][0] # choose gage of max damage
            damage = self.plotMeanDamageOnGage(v, spot[4], ax)
            damages.append(damage)
        # Common axes lables
        # plt.subplots_adjust(left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
        fig.suptitle('Distribution of mean damage at different wind speed')
        fig.text(0.5, 0.03, 'Perimeter: spot angle θ (°)', ha='center', va='center')
        fig.text(0.02, 0.5, 'Radius: Average of cumulative damage in {} runs '
                 '(normolized to local maximum)'.format(int(len(self.seeds)/len(self.listOfSpeed))),
                 ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
        return damages

    def compareMeanDamageOnGage(self, speed, gage, axisInput, damageInput, normed=True):
        # get and sort data
        temp = collections.deque()
        for elem in self.wind[speed]['MeanDamages']:
            if elem[0][4] == gage:
                temp.append( (math.radians(float(elem[0][6:])), elem[1]) )
        temp = list(temp)
        temp.sort()
        # decompose to vectors for plotting
        X = collections.deque()
        Y = collections.deque()
        for elem in temp:
            X.append(elem[0])
            Y.append(elem[1])
        X.append(X[0]) # in order to close circle in radar graph
        Y.append(Y[0])
        # normolize the average of cumulative damage by its maximum value
        if normed:
            yMax = max(max(Y), max(damageInput[1]))
            Y = [y/yMax for y in Y]
            Ycompared = [y/yMax for y in damageInput[1]]
        else:
            Ycompared = damageInput[1]
        # plot in polar coordinates
        if axisInput is None:
            axis = plt.subplot(111, polar=True)
        else:
            axis = axisInput
        # plot data
        axis.plot(X, Y, '-', linewidth=1, label='1000 runs')
        axis.plot(damageInput[0], Ycompared, '-', linewidth=1, label='100 runs')
        axis.fill_between(X, Y, Ycompared, alpha=0, edgecolor='gray', hatch='xxxx') # facecolor='tab:grey',
        if normed: axis.set_rlim(0, 1)
        #*common settings of axes
        axis.set_rlabel_position(-90) # change radius labels location [degree]
        axis.set_thetagrids(range(0,360,30)) # change theta gridlines
        if normed:
            axis.text(1.15, 0.1, 'max. = {:.2e}'.format(yMax), ha='center',
                      va='center', transform=axis.transAxes)
        if axisInput is None:
            axis.fill(X, Y)
            axis.set_title('Compare: Distribution of mean damage at wind speed '
                           '{} m/s on tower gage {}'.format(speed, gage))
            plt.show()
            plt.close()
        else:
            axis.set_title('{} m/s gage {}'.format(speed, gage), pad=-30)

    def compareMeanDamageForAllSpeeds(self, damageInput, shareXaxis=False,
                                      shareYaxis=True, normed=True, toPDF=[]):
        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis,
                        tight_layout=False, subplot_kw=dict(projection='polar'))
        axes = [axis for ax in axes for axis in ax]
        # The minor subplots
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            spot = self.wind[v]['MaxSpot'][0] # choose gage of max damage
            damage = self.compareMeanDamageOnGage(v, spot[4], ax, normed=normed,
                                                  damageInput=damageInput[ind])
        # Common axes lables
        fig.legend(['1000 runs', '100 runs'])
        fig.suptitle('Compare: Distribution of mean damage between 1000 runs '
                     'and 100 runs')
        fig.text(0.5, 0.03, 'Perimeter: spot angle θ (°)', ha='center', va='center')
        fig.text(0.02, 0.5, 'Radius: Average of cumulative damage (normolized '
                 'to local maximum)'.format(int(len(self.seeds)/len(self.listOfSpeed))),
                 ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)

    def plotMeanDamageOfTower(self, speed, shareXaxis=False, shareYaxis=True, normed=True,
                                   toPDF=[]):
        fig, axes = plt.subplots(3, 3, sharex=shareXaxis, sharey=shareYaxis,
                        tight_layout=False, subplot_kw=dict(projection='polar'))
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            self.plotMeanDamageOnGage(speed, str(ind+1), ax, normed)
        # Common axes lables
        # plt.subplots_adjust(left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
        fig.suptitle('Distribution of mean damage at wind speed {} m/s'
                     .format(speed))
        fig.text(0.5,0.03,'Perimeter: spot angle θ (°)',ha='center',va='center')
        if normed:
            fig.text(0.02,0.5,'Radius: Average of cumulative damage in {} runs '
                     '(normolized to local maximum)'.format(int(len(self.seeds)/
                     len(self.listOfSpeed))), ha='center', va='center',
                     rotation='vertical')
        else:
            fig.text(0.02,0.5,'Radius: Average of cumulative damage in {} runs '
                     .format(int(len(self.seeds)/len(self.listOfSpeed))),
                     ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)

    #*          ==================== Statistics ====================
    def plotConvergentChart(self, speed, theta, step, axisInput=None):
        # calculate median value
        data = list(self.wind[speed]['TowerGage1']['TwHt1@'+str(theta)])
        length = len(data)
        i, X, Y = 1, [], []
        while True:
            x = int(i*step)
            if x > length:
                break
            else:
                X.append(x)
                y = pystats.median(data[:x])
                Y.append(y)
                i = i + 1
        # plot convergence curve
        if axisInput is None:
            fig, axis = plt.subplots()
        else:
            axis = axisInput
        axis.plot(X, Y)
        chart.adjust(axis, loc=None, minor=[0, 0, 0, 0], xlabel="",
                     xlim=[0, length], seperator=False)
        if axisInput is None:
            axis.set_title('Convergence at {} m/s gage 1'.format(speed))
        else:
            axis.set_title('{} m/s gage 1'.format(speed), pad=-30)

    def plotConvergentChartForAllSpeeds(self, step, shareXaxis=True,
                                        shareYaxis=False, toPDF=[]):
        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis,
                                 tight_layout=False)
        axes = [axis for ax in axes for axis in ax]
        for (ind, ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            self.plotConvergentChart(v, "0", step, ax)

        numberOfRuns = int(len(self.seeds)/len(self.listOfSpeed))
        fig.suptitle("Curve of convergence for median value in {} runs".format(
                     numberOfRuns))
        fig.text(0.5, 0.03, "Cumulative runs", ha='center', va='center')
        fig.text(0.02, 0.5, "Median value of damage", ha='center', va='center',
                 rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.06,
                   right=0.94, top=0.94, wspace=0.14, hspace=0.14)

class Lifetime(object):
    """ Evaluate fatigue damange in lifetime
    """
    def __init__(self, measure_file, measure_duration, measure_height,
        wind_speed_range, distribution_directory, years, quantile, zhub,
        simulated_time):
        self.rawdata = pd.read_csv(measure_file, delimiter=";", header=None)
        self.measure_duration = measure_duration
        self.measure_height = measure_height
        self.wind_range = wind_speed_range
        self.distr_dir = Path(distribution_directory).expanduser()
        self.years = years
        # self.quantile = 1 - 1/self.years
        self.quantile = quantile
        self.simulated_time = simulated_time
        self.zhub = zhub
        # calculate delta v
        self.delta_speed = abs((self.wind_range[0]-self.wind_range[1])/2.0)
        self.theta = pd.DataFrame(list(range(0, 360, 10)))
        self._convert_to_hub_speed()

    def _convert_to_hub_speed(self):
        """ Preprocess the wind speed from measuring height to hub height
        """
        temp = self.rawdata.iloc[:, [3, 2]].copy()
        z, zhub, alpha = self.measure_height, self.zhub, 0.2
        temp.iloc[:,1] = temp.iloc[:, 1] / ((z/zhub)**alpha)
        self.measure_data = temp
        self.measure_data.columns = ["direction", "speed"]

    def plot_wind_rose(self, bins, normed=True, show=False):
        ax = WindroseAxes.from_ax()
        ax.bar(self.measure_data.direction, self.measure_data.speed,
               bins=bins, normed=normed, opening=0.9)
        ax.set_legend()
        if normed:
            ax.set_title("Polar rose plot at {} m (normalized)".format(
                self.zhub))
            ylabels = [item.get_text() for item in ax.get_yticklabels()]
            newlabels = [s+"%" for s in ylabels]
            ax.set_yticklabels(newlabels)
        else:
            ax.set_title("Polar rose plot at {} m (not normalized)".format(
                self.zhub))
        if show:
            plt.show()
        else:
            plt.close()

    def select_speed_range(self, speed, show=False):
        """ Filter data by wind speed between vmin (included) and vmax (not 
        included)
        """
        vmin, vmax = speed - self.delta_speed, speed + self.delta_speed
        df = self.measure_data.loc[(vmin <= self.measure_data.loc[:, "speed"]) &
            (self.measure_data.loc[:, "speed"] < vmax)]        
        if not df.any(axis=None).speed: # if wind doesn't occur in this range
            res = pd.DataFrame(0.0, index=range(0, 360, 10), columns=["Time"])
            return res
        else:
            # find out the appearance of wind in every direction
            wd_count = np.histogram(df.direction, bins=np.arange(0, 370, 10))
            wd_time = wd_count[0] * self.measure_duration
            res = pd.DataFrame(wd_time, index=range(0, 360, 10),
                columns=["Time (min)"])
        # plot result by bar
        if show:
            axis = plt.subplot()
            axis.bar(np.arange(0, 360, 10), wd_time, width=8)
            axis.grid(axis='y')
            axis.set_xlabel("Wind direction (°)")
            axis.set_ylabel("Time (min)")
            axis.set_xticks(np.arange(0, 360, 10))
            axis.set_title("Wind directions at mean speed {} m/s".format(
                (vmin+vmax)/2.0))
            plt.show()
        return res

    def load_sts(self, speed):
        filename = self.distr_dir.joinpath("10000@{}mps.sts".format(speed))
        unit_damage = {}
        with filename.open() as f:
            rawdata = json.loads(f.read())
            for elem in rawdata:
                # theta
                key = elem.keys()
                theta = int(list(key)[0])
                # get saved information
                info = list(elem.values())[0]
                dist_name = info[0].get("Name")
                dist_param = info[0].get("Parameters")
                # get distribution object by name
                dist = getattr(scipy.stats, dist_name)
                # add to the set of distributions
                unit_damage[theta] = dist.ppf(self.quantile, *dist_param[:-2],
                    loc=dist_param[-2], scale=dist_param[-1])
        res = pd.DataFrame.from_dict(unit_damage, orient="index")
        return res

    def calculate_damage_direction(self, wind_direction_time, unit_damage,
        show=False):
        """ Evaluate fatigue damage between a given speed range for all wind
            directions
            INPUT
                wind_direction_time: cumulative time for wind from all 
                    directions [pandas.DataFrame]
                unit_damage: cumulative fatigue damage on a tower gage for all 
                    spots [pandas.DataFrame]
        """
        amplifier = wind_direction_time.div(self.simulated_time)
        multiplication = pd.DataFrame(amplifier.values * 
            unit_damage.T.values)
        # Convert tower gage polar coordinates to wind polar coordinates
        all_damages = pd.DataFrame()
        for i in range(0, 36, 1):
            row = multiplication.iloc[[i]]
            index = (self.theta.T*(-1) + i*10).mod(360)
            row.columns = index.values.tolist()
            row = row.reindex(sorted(row.columns), axis=1)
            all_damages = all_damages.append(row)
        all_damages.index = self.theta.T.values.tolist()  # row: wind direction;
            # column: angle in polar coordinates
        # plot damage induced by individual wind direction
        if show:
            axis = plt.subplot(111, polar=True)
            axis.set_theta_zero_location("N")  # set angle=0 at the top
            axis.set_theta_direction(-1)  # set angle increasing clockwise
            axis.set_thetagrids(range(0, 360, 30))  # change theta gridlines
            X = np.radians(self.theta)
            X = X.append(X.iloc[0], ignore_index=True)
            for i in range(0, 360, 10):
                Y = all_damages.loc[i].T
                Y = Y.append(Y.iloc[0], ignore_index=True)
                axis.plot(X, Y.values, label="Wind from {} degree".format(i))
            plt.show()
        return all_damages

    def calculate_damage_speed(self, speed, damages_direction, show=False):
        """ Calculate total damage between a given wind speed range
            INPUT
                damages_direction: fatigue damage induced by wind from every
                    direction [DataFrame]
        """
        damage = damages_direction.sum(axis=1)
        res = pd.DataFrame(damage, columns=[str(speed)])
        if show:
            axis = plt.subplot(111, polar=True)
            axis.set_theta_zero_location("N")  # set angle=0 at the top
            axis.set_theta_direction(-1)  # set angle increasing clockwise
            axis.set_thetagrids(range(0, 360, 30))  # change theta gridlines
            X = np.radians(self.theta)
            X = X.append(X.iloc[0], ignore_index=True)
            Y = res.append(res.iloc[0], ignore_index=True)
            axis.plot(X, Y)
            axis.set_title("Damage at {} m/s for 1 year".format(speed))
            plt.show()
        return res

    def evaluate_fatige_speed(self, show=False):
        """ Evaluate fatigue induced by different wind speed during measuring
            period
        """
        res = pd.DataFrame()
        for v in self.wind_range:
            wd_time = self.select_speed_range(speed=v)
            unit_dam = self.load_sts(speed=v)
            dam_dir = self.calculate_damage_direction(
                wind_direction_time=wd_time, unit_damage=unit_dam)
            dam_speed = self.calculate_damage_speed(speed=v,
                                                    damages_direction=dam_dir)
            res = pd.concat([res, dam_speed], axis=1)
        if show:
            axis = plt.subplot(111, polar=True)
            axis.set_theta_zero_location("N")  # set angle=0 at the top
            axis.set_theta_direction(-1)  # set angle increasing clockwise
            axis.set_thetagrids(np.arange(0, 360, 22.5))
            X = np.radians(self.theta)
            X = X.append(X.iloc[0], ignore_index=True)
            Y = res.append(res.iloc[0], ignore_index=True)
            axis.plot(X, Y)
            axis.legend(Y.columns.values + " m/s")
            axis.set_title("Cumulative fatigue during measuring period (1 year)"
                )
            xlabels = ('N', '', 'N-E', '', 'E', '', 'S-E', '', 'S', '', 'S-W', 
                '', 'W', '', 'N-W', '',)
            axis.set_xticklabels(xlabels)
            plt.show()
        return res

    def evaluate_fatige_life(self, show=False):
        """ Calculate fatigue damage for fixed years
        """
        unit_fatigue_per_speed = self.evaluate_fatige_speed(show=False)
        unit_fatigue = unit_fatigue_per_speed.sum(axis=1)
        res = pd.DataFrame(unit_fatigue * self.years)
        if show:
            axis = plt.subplot(111, polar=True)
            axis.set_theta_zero_location("N")  # set angle=0 at the top
            axis.set_theta_direction(-1)  # set angle increasing clockwise
            axis.set_thetagrids(np.arange(0, 360, 22.5))
            X = np.radians(self.theta)
            X = X.append(X.iloc[0], ignore_index=True)
            Y = res.append(res.iloc[0], ignore_index=True)
            axis.plot(X, Y, label="Tower gage 1")
            axis.legend()
            axis.set_title("Cumulative fatigue for {} years".format(self.years))
            xlabels = ('N', '', 'N-E', '', 'E', '', 'S-E', '', 'S', '', 'S-W',
                       '', 'W', '', 'N-W', '',)
            axis.set_xticklabels(xlabels)
            plt.show()
        return res


#!------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!------------------------------------------------------------------------------



#!------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!------------------------------------------------------------------------------
def main():
    essai = 3

    if essai == 1:
        test = Damage('NTM_25mps', False)
        print(test.maxDamage, test.maxSpot)

    if essai == 2:
        with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'):
            with open('100seeds.json', 'r') as f:
                seeds = json.loads(f.read())

        liste = []
        [liste.append(s) for s in seeds if s[0] == "NTM"]
        seeds = liste[:100]

        test = Analysis(seeds)

    if essai == 3:
        test = Lifetime(
        measure_file="~/Eolien/Parameters/Normandy/data/SM_Caen_2009 UV.csv",
        measure_duration=30, measure_height=10,
        wind_speed_range=range(3, 27, 2),
        distribution_directory="~/PhD/Memo/DLC1.1b/Figures/10000seeds",
        years=20, quantile=0.95, zhub=80, simulated_time=10)
        
        # wd_time = test.select_speed_range(speed=23, show=0)
        # print(wd_time)
        # unit_dam = test.load_sts(speed=23)
        # print(unit_dam)
        # dam_dir = test.calculate_damage_direction(wind_direction_time=wd_time,
        #     unit_damage=unit_dam, show=0)
        # print(dam_dir)
        # test.calculate_damage_speed(speed=23, damages_direction=dam_dir, show=0)
        
        test.evaluate_fatige_speed(show=1)
        exit()
        test.evaluate_fatige_life(show=1)
        
    
    if essai == 33:
        axis = plt.subplot()
        X = range(2, 71, 2)
        Y = []
        for year in X:
            print("Evaluating year {} ...".format(year), end=" ")
            test = Lifetime(
                measure_file="~/Eolien/Parameters/Normandy/data/SM_Caen_2009 UV.csv",
                measure_duration=30, measure_height=10,
                wind_speed_range=range(3, 27, 2),
                distribution_directory="~/PhD/Memo/DLC1.1b/Figures/10000seeds",
                years=year, quantile=0.95, zhub=80, simulated_time=10)

            fatigue = test.evaluate_fatige_life(show=0)
            res = fatigue.sum().values
            print("Fatigue =", res)
            Y.extend(res)
        axis.plot(X,Y, 'o-')
        axis.grid()
        axis.set_title("Fatigue evolution in time")
        axis.set_xlabel("Years")
        axis.set_ylabel("Cumulative fatigue damage")
        plt.show()

#!------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
