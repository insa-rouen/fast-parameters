#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Some common useful functions
#
#
# Authors: Hao BAI
# Date: 17/10/2018
#
# Version:
#   - 0.0: Initial version
#   
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================

#*============================== Modules Communs ==============================
# import csv, copy
import os
# import numpy
import json
import pandas
import time
import collections
import subprocess
# from scipy import signal
from contextlib import contextmanager
from pathlib import Path
import numpy as np
import multiprocessing
import multiprocessing.pool



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class Input(object):
    ''' Save data reading from files
        Attributes:
            data: a dictionary of all data labeled by channel name in FAST [ordered dict]
        Methods:
            get(): get values by channel name or channel number
    '''
    def __init__(self):
        self.data = collections.OrderedDict()
    
    def get(self, index):
        if isinstance(index, str):
            return self.data[index] # get by channel name in FAST output file
        elif isinstance(index, int):
            return list(self.data.values())[index-1] # get by channel number
        else:
            raise TypeError("[Error] index type is not allowable, should be str or int")

    def getkeys(self):
        return list(self.data.keys())



#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
@contextmanager
def cd(newdir):
    prevdir = os.getcwd() # save current working path
    os.chdir(os.path.expanduser(newdir)) # change directory
    try:
        yield
    finally:
        os.chdir(prevdir) # revert to the origin workinng path

def frange(start, stop=None, step=None, precision=None):
    ''' Return a list of float numbers
        Syntax:
            range(stop)
            range(start, stop[, step][, precision])
    '''
    # check how many inputs
    if stop is None and step is None and precision is None:
        return frange(0.0, start)
    # set default step
    if step is None:
        temp = str(stop).lstrip('1234567890')
        if temp == '':
            step = 1.0
        else:
            step = 10**(-(len(temp)-1))
    # set default precision
    if precision is None:
        fois = 1e7
    else:
        fois = 10**precision
    # amplify float number to int number
    new_start = int(start * fois)
    new_stop = int(stop * fois)
    new_step = int(step * fois)
    r = range(new_start, new_stop, new_step)
    # convert int number to float number
    l = [i/fois for i in r]
    return l

def readcsv(filename, delimiter='\t', header=7, datarow=9, unitrow=None, echo=True):
    ''' Read a csv-like file into ordered dictionary
        Syntax:
            readcsv(filename[, delimiter[, header[, datarow[, echo]]]])
        Input:
            filename: name of file to be opened [string]
            delimiter: seperator [string]
            header: line number that contains column's name [int]
            datarow: line number that contains the first row of data [int]
            echo: True/False to print elapsed time on screen [boolean]
    '''
    TIK = time.time()
    result = Input()
    header = header - 1
    datarow = datarow - 1
    # read file by using padas
    dataframe = pandas.read_csv(filename, delimiter=delimiter, encoding='ISO-8859-1',
                                header=header, skip_blank_lines=False)
    # don't use set low_memory=False, dtype=str => will be slower    
    # skip rows between header and datarow
    if datarow-header >= 2:
        endIndex = (datarow-header)-1
        if unitrow is not None:
            dataframe.drop(list(range(unitrow-header,endIndex)), inplace=True)
        else:
            dataframe.drop(list(range(endIndex)), inplace=True)
    # read data column by column
    for i in range(dataframe.columns.size):
        name = dataframe.columns[i] # get the column head
        if datarow-header >= 2 and unitrow is not None: # get unit ONLY if it's a FAST output file (.out)
            unit = dataframe.iloc[0,i].strip()
            records = dataframe.iloc[1:,i].values.astype('float') # get values in float
        else:
            unit = "(-)"
            records = dataframe.iloc[:,i].values.astype('float') # get values in float        
        result.data[name.strip()] = {'Title':name, 'Records':list(records), 'Unit': unit}
    TOK = time.time()
    if echo: print("|-", filename, "loaded in", "%.2f"%(TOK-TIK), "s")
    return result

def readfwf(filename, widths=(11,11), header=12, datarow=14, echo=True):
    ''' Read a fixed-width formatted file into ordered dictionary
        Syntax:
            readfwf(filename[, widths[, header[, datarow[, echo]]]])
        Input:
            filename: name of file to be opened [string]
            widths: list of field widths [list of int]
            header: line number that contains column's name [int]
            datarow: line number that contains the first row of data [int]
            echo: True/False to print elapsed time on screen [boolean]
    '''
    TIK = time.time()
    result = Input()
    header = header - 1
    datarow = datarow - 1
    dataframe = pandas.read_fwf(filename, widths=widths, header=header)
    # skip rows between header and datarow
    if datarow-header >= 2:
        endIndex = (datarow-header)-1
        dataframe.drop(list(range(endIndex)), inplace=True)
    # read data column by column
    for i in range(dataframe.columns.size):
        name = dataframe.columns[i] # get the column head
        records = dataframe.iloc[:,i].values.astype('float') # get values in float
        result.data[name.strip()] = {'Title':name, 'Records':list(records)}
    TOK = time.time()
    if echo: print("|-", filename, "loaded in", "%.2f"%(TOK-TIK), "s")
    return result

def timer(function):
    ''' Decorator for timing
    '''
    def wrapper(*args, **kwargs):
        tik = time.time()
        result = function(*args, **kwargs)
        tok = time.time()
        print("[INFO] {}() finished in {:.3f} s".format(function.__name__, tok-tik))
        return result
    return wrapper

def handle_error(error):
    ''' What to do if an error occurs in multiprocessing
    '''
    with open('error.log','a') as f:
        f.write('{}\n'.format(error))
    print("[ERROR] An error occurs during multiprocessing:\n{}".format(error))

def format_seconds(timeInSeconds):
    ''' Format time in seconds
    '''
    day = 24*60*60
    hour = 60*60
    minute = 60
    if timeInSeconds > day:
        days = timeInSeconds//day
        rest = format_seconds(timeInSeconds%day)
        return '{:.0f} days {}'.format(days, rest)
    elif timeInSeconds > hour:
        hours = timeInSeconds//hour
        rest = format_seconds(timeInSeconds%hour)
        return '{:.0f} hours {}'.format(hours, rest)
    elif timeInSeconds > minute:
        minutes = timeInSeconds//minute
        rest = format_seconds(timeInSeconds%minute)
        return '{:.0f} minutes {}'.format(minutes, rest)
    else:
        return '{:.2f} seconds'.format(timeInSeconds)

def compress(filename, removeSource):
    if removeSource:
        command = 'tar -czf {0}.tgz {0} && rm {0}'.format(filename)
    else:
        command = 'tar -czf {0}.tgz {0}'.format(filename)
    try:
        output = subprocess.check_call([command], shell=True)
    except Exception as e:
        raise e
    return filename

def add_failed_seeds(programName, identity):
    ''' Collect simulation identities (seed ID, filebase name, ...) that has an error during execution
    '''
    # prepare collected file
    filename = Path('~/Eolien/Parameters/NREL_5MW_Onshore/Wind')
    filename = filename.joinpath('failedRuns{}.json'.format(programName)).expanduser()
    # initiate data
    if filename.exists():
        data = json.loads(filename.read_text())
    else:
        data = []
    # convert identity to seed if it's in string format
    
    if isinstance(identity, str):
        seed = identity.split('_')
        seed[1] = seed[1].rstrip('mps')
        identity = seed
    data.append(identity)
    # write to disk
    encode = json.dumps(data, indent=4)
    filename.write_text(encode)


#TODO
def multiprocess(function):
    ''' Decorator for multiprocessing
    '''
    def wrapper(self, list_for_map):
        pool = multiprocessing.Pool()
        # pool = multiprocessing.pool.ThreadPool()
        # [pool.apply_async(function, args=(variables,)) for filebase in list_filebase]
        result = pool.map(function, list_for_map)
        pool.close()
        pool.join()
        return result
    return wrapper


#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    # print("frange(3) =", frange(3))
    # print("frange(3,5) =", frange(3,5))
    # print("frange(3,4.02) =", frange(3,4.02))
    # print("frange(5,9,2) =", frange(5,9,2))
    # print("frange(5,7,0.5) =", frange(5,7,0.5))
    # print("-----")

    # test = readcsv('csv.out', unitrow=8)
    # print(test.get(2))
    # print(test.get('Wind1VelX'))
    # test = readfwf('fwf.ext')
    # print(test.get(1))
    # print(test.get('Time'))
    # print(test.getkeys()[0])
    # test.get(1.0) # raise error
    # print("-----")

    # compress('csv.out')
    

    pass


#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
