#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Distribute computing tasks
#
#
# Authors: Hao BAI
# Date: 01/11/2018
#
# Version:
#   - 0.0: Initial version
#   - 0.1: Valid version
#   - 0.2: Split tasks according to a fixed ratio based on computing power
#   - 0.3: Improve auto alloation algorithm
#   - 0.4: Add a resume method to continue unfinished tasks
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import math
import platform
from pathlib import Path
from collections import OrderedDict

#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class LMN(object):
    ''' Computers in Laboratoire de Mécanique de Normandie
        Attributes:
            nodes: available computer names [list]
        Methods:
            get(): get tasks by channel name or channel number
    '''
    def __init__(self, windPath, echo=True):
        self.windPath = windPath
        self.echo = echo
        self._nodes = OrderedDict()
        self._nodes['PC-LMN-7010A'] = [1] # Hao BAI
        self._nodes['PC-LMN-7050'] = [2] # Chao REN
        self._nodes['PC-LMN-7040'] = [3]
        self._nodes['PC-LMN-9010'] = [4] # Changwu HUANG
        self._nodes['PC-LMN-1600A'] = [5] # Surke ALJAMEL
        self._nodes['PC-LMN-1600B'] = [6] # Corentin LOTHODE
        # self._nodes['PC-LMN-9020'] = [7] # Shubiao WANG
        self._nodes['PC-LMN-9020A'] = [8]
        self._nodes['PC-LMN-9020B'] = [9]
        if platform.node() == 'MacBook-Pro-de-Hao.local': # only for testing
            self._nodes['MacBook-Pro-de-Hao.local'] = [99]

        self._timeRatio = OrderedDict()
        self._timeRatio['PC-LMN-7010A'] = 717 # Hao BAI
        self._timeRatio['PC-LMN-7050'] = 567 # Chao REN
        self._timeRatio['PC-LMN-7040'] = 566
        self._timeRatio['PC-LMN-9010'] = 923 # Changwu HUANG
        self._timeRatio['PC-LMN-1600A'] = 710 # Surke ALJAMEL
        self._timeRatio['PC-LMN-1600B'] = 707 # Corentin LOTHODE
        # self._timeRatio['PC-LMN-9020'] = 719 # Shubiao WANG
        self._timeRatio['PC-LMN-9020A'] = 700
        self._timeRatio['PC-LMN-9020B'] = 698
        if platform.node() == 'MacBook-Pro-de-Hao.local': # only for testing
            self._timeRatio['MacBook-Pro-de-Hao.local'] = 999
        
        self._quota = OrderedDict.fromkeys(self._nodes.keys(), None)
        self._length = OrderedDict.fromkeys(self._nodes.keys(), None)
        self._allocation = OrderedDict.fromkeys(self._nodes.keys(), None) # number of tasks to be allocated
        self._currentComputer = platform.node()

        if self.echo:
            print('Distributed Computing v0.4 (November 26 2018)')
            print('========== Pre-processing ==========')

    def setIndividually(self, computerName, tasks):
        self._nodes[computerName] = tasks
        self._length[computerName] = len(tasks)
        estimateTime = self._timeRatio[computerName] * math.ceil(self._length[computerName]/8)
        formatedTime = utils.format_seconds(estimateTime)
        print('|- {} tasks are affected to computer {} and wished to terminate in {}'
              .format(self._length[computerName], computerName, formatedTime))

    def setEqually(self, tasks):
        tasksLength = len(tasks)
        chunkLength = int(tasksLength/len(self._nodes))
        for key in self._nodes.keys():
            self._allocation[key] = chunkLength
        # add the residue task to the last computer
        cumulLength = len(self._nodes) * chunkLength
        if cumulLength != tasksLength:
            residue = tasksLength - cumulLength
            self._allocation[key] = self._allocation[key] + residue
        print('{} tasks will be equally splited into {} partitions'.format(tasksLength,
              len(self._nodes)))
        self._allocate(tasks)

    def setAutomatically(self, tasks):
        # calculate distribution quota of every computer
        self._calculateQuota()
        # divide tasks into partitions
        tasksLength = len(tasks)
        cumulLength = 0
        # 1st allocation: by chunk of 8
        for key in self._nodes.keys():
            numberOfChunks = tasksLength * self._quota[key] // 8
            self._allocation[key] = int(numberOfChunks * 8)
            cumulLength = cumulLength + self._allocation[key]
        # 2nd allocation: by chunk of 4 for the rest
        tasksLength = tasksLength - cumulLength
        cumulLength = 0
        for key in self._nodes.keys():
            numberOfChunks = tasksLength * self._quota[key] // 4
            numberOfTasks = int(numberOfChunks * 4)
            self._allocation[key] = self._allocation[key] + numberOfTasks
            cumulLength = cumulLength + numberOfTasks
        # 3rd allocation: add the residue task to a computer
        if cumulLength != tasksLength:
            residue = tasksLength - cumulLength
            self._allocation['PC-LMN-7040'] = self._allocation['PC-LMN-7040'] + residue
        print('{} tasks will be splited into {} partitions based on computing power'
              .format(len(tasks), len(self._nodes)))
        self._allocate(tasks)

    def _calculateQuota(self):
        totalPower = sum([1/v for v in self._timeRatio.values()])
        for (key, value) in self._timeRatio.items():
            self._quota[key] = (1/value) / totalPower

    def _allocate(self, tasks):
        # allocate tasks to computers
        for (key, value) in self._allocation.items():
            chunk = tasks[:value]
            tasks = tasks[value:]
            self.setIndividually(key, chunk)

    def show(self):
        for (key, value) in self._nodes.items():
            print('|- {} refers to a {} of length {}'.format(key,type(value),
                  self._length[key]))

    def resume(self, programName='TurbSim', outputFileSize=70*1024**2):
        print("========== Resume Mode ==========")
        if programName.lower() == 'TurbSim'.lower():
            outputList = self._find(self.windPath, '*.bts', outputFileSize)
            inputList = ['{}_{}mps_{}'.format(s[0], s[1], s[2]) for s in self._nodes.get(self._currentComputer)]
            recompute = list(set(inputList).difference(set(outputList)))
            self._nodes[self._currentComputer] = self._convertToSeed(recompute)
            self._length[self._currentComputer] = len(self._nodes[self._currentComputer]
) 
    def _convertToSeed(self, list_filebase):
        result = []
        for filebase in list_filebase:
            seed = filebase.split('_')
            if len(seed) < 3: continue
            seed[1] = seed[1].rstrip('mps')
            result.append(seed)
        return result

    def _find(self, path, pattern, size):
        ''' size: minimum size in bytes (1 GB = 1024 MB = 1024^2 KB = 1024^3 Bytes) [num]
        '''
        with utils.cd(path):
            p = Path().expanduser()
            matched = sorted(p.glob(pattern))
            if size is None:
                result = [x.stem.split('.')[0] for x in matched]
            else:
                result = [x.stem.split('.')[0] for x in matched if x.stat().st_size >= size]
        return result

    def run(self, function, *args):
        if self.echo:
            print('You are running on computer {}'.format(self._currentComputer))
            print('Function {} will be called {} times'.format(function,
                  self._length.get(self._currentComputer)))
            print('========== Computing Starts ==========')
        # execution
        if self._nodes.get(self._currentComputer) is None:
            raise Exception("|- [ERROR] The computer {} is an unknown device".format(
                            self._currentComputer))
        else:
            tasks = self._nodes.get(self._currentComputer)
            if len(args) == 0: function(tasks)
            if len(args) == 1: function(tasks, args[0])
            if len(args) == 2: function(tasks, args[0], args[1])
            if len(args) == 3: function(tasks, args[0], args[1], args[2])
            if len(args) == 4: function(tasks, args[0], args[1], args[2], args[3])



#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    test = LMN()
    tasks=[1]*10
    test.setAutomatically(tasks)
    # test.show()



#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
