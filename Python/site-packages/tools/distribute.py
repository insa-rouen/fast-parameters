#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Distribute computing tasks
#
#
# Authors: Hao BAI
# Date: 01/11/2018
#
# Version:
#   - 0.0: Initial version
#   - 0.1: Valid version
#   - 0.2: Split tasks according to a fixed ratio based on computing power
#   - 0.3: Improve auto alloation algorithm
#   - 0.4: Add a resume method to continue unfinished tasks
#   - 0.5: Add a method to deactivate temporarily a computer 
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!------------------------------------------------------------------------------
#*============================== Modules Personnels ============================
from tools import utils
#*============================== Modules Communs ==============================
# import json
import math
import platform
from pathlib import Path
from collections import OrderedDict

#!------------------------------------------------------------------------------
#!                                         CLASS
#!------------------------------------------------------------------------------
class LMN(object):
    ''' Computers in Laboratoire de Mécanique de Normandie
        Attributes:
            nodes: available computer names [list]
        Methods:
            get(): get tasks by channel name or channel number
    '''
    def __init__(self, windPath, echo=True):
        self.windPath = windPath
        self.echo = echo
        self._nodes = OrderedDict()
        self._nodes['PC-LMN-7010A'] = [1] # Hao BAI
        self._nodes['PC-LMN-7010B'] = [2] # Hao BAI
        self._nodes['PC-LMN-7040'] = [3] # 1TB
        self._nodes['PC-LMN-9010'] = [4] # Changwu HUANG
        self._nodes['PC-LMN-1600A'] = [5] # Surke ALJAMEL
        self._nodes['PC-LMN-1600B'] = [6] # Corentin LOTHODE
        self._nodes['PC-LMN-9020A'] = [7]
        self._nodes['PC-LMN-9020B'] = [8]
        self._nodes['PC-LMN-7050'] = [9] # Chao REN
        self._nodes['PC-LMN-9020'] = [10] # Shubiao WANG
        self._nodes['PC-LMN-MECA16'] = [11]  # Wilson
        if platform.node() == 'MacBook-Pro-de-Hao.local' or 'mecap-086.insa-rouen.fr':  # only for testing
            self._nodes['MacBook-Pro-de-Hao.local'] = [99]
            self._nodes['mecap-086.insa-rouen.fr'] = [99]

        self._timeRatio = OrderedDict()
        self._timeRatio['PC-LMN-7010A'] = 2584 # Hao BAI
        self._timeRatio['PC-LMN-7010B'] = 2625 # Hao BAI
        self._timeRatio['PC-LMN-7040'] = 2053 # 1TB
        self._timeRatio['PC-LMN-9010'] = 2778 # Changwu HUANG
        self._timeRatio['PC-LMN-1600A'] = 1746 # Surke ALJAMEL
        self._timeRatio['PC-LMN-1600B'] = 1750 # Corentin LOTHODE
        self._timeRatio['PC-LMN-9020A'] = 2175
        self._timeRatio['PC-LMN-9020B'] = 2184
        self._timeRatio['PC-LMN-7050'] = 2058 + 200 # Chao REN
        self._timeRatio['PC-LMN-9020'] = 2184 # Shubiao WANG
        self._timeRatio['PC-LMN-MECA16'] = 2222  # Wilson
        if platform.node() == 'MacBook-Pro-de-Hao.local' or 'mecap-086.insa-rouen.fr':  # only for testing
            self._timeRatio['MacBook-Pro-de-Hao.local'] = 99
            self._timeRatio['mecap-086.insa-rouen.fr'] = 99
        
        self._quota = OrderedDict.fromkeys(self._nodes.keys(), None)
        self._length = OrderedDict.fromkeys(self._nodes.keys(), None)
        self._allocation = OrderedDict.fromkeys(self._nodes.keys(), None) # number of tasks to be allocated
        self._currentComputer = platform.node()

        if self.echo:
            print('Distributed Computing v0.5 (December 3 2018)')
            print('========== Pre-processing ==========')

    def deactivate(self, index):
        """ Remove a computer from available list
        """
        try:
            if isinstance(index, str):
                found = True
                key = index
            elif isinstance(index, int):
                for (key,value) in self._nodes.items():
                    if index in value:
                        found = True
                        break
            else:
                raise
            if found:
                self._nodes.pop(key)
                self._timeRatio.pop(key)
                self._quota.pop(key)
                self._length.pop(key)
                self._allocation.pop(key)
            else:
                raise ValueError("[ERROR] {} is not a valid number of index"
                                 .format(index))
        except:
            raise Exception("[ERROR] {} is a wrong index of computer, it is not"
                            " contained in the list of available computers"
                            .format(index))

    def setIndividually(self, computerName, tasks):
        self._nodes[computerName] = tasks
        self._length[computerName] = len(tasks)
        estimateTime = self._timeRatio[computerName] * math.ceil(self._length[computerName]/8)
        formatedTime = utils.format_seconds(estimateTime)
        print('|- {} tasks are affected to computer {} and wished to terminate in {}'
              .format(self._length[computerName], computerName, formatedTime))

    def setEqually(self, tasks):
        tasksLength = len(tasks)
        chunkLength = int(tasksLength/len(self._nodes))
        for key in self._nodes.keys():
            self._allocation[key] = chunkLength
        # add the residue task to the last computer
        cumulLength = len(self._nodes) * chunkLength
        if cumulLength != tasksLength:
            residue = tasksLength - cumulLength
            self._allocation[key] = self._allocation[key] + residue
        print('{} tasks will be equally splited into {} partitions'.format(tasksLength,
              len(self._nodes)))
        self._allocate(tasks)

    def setAutomatically(self, tasks):
        # calculate distribution quota of every computer
        self._calculateQuota()
        # divide tasks into partitions
        tasksLength = len(tasks)
        cumulLength = 0
        # 1st allocation: by chunk of 8
        for key in self._nodes.keys():
            numberOfChunks = tasksLength * self._quota[key] // 8
            self._allocation[key] = int(numberOfChunks * 8)
            cumulLength = cumulLength + self._allocation[key]
        # 2nd allocation: by chunk of 4 for the rest
        tasksLength = tasksLength - cumulLength
        cumulLength = 0
        for key in self._nodes.keys():
            numberOfChunks = tasksLength * self._quota[key] // 4
            numberOfTasks = int(numberOfChunks * 4)
            self._allocation[key] = self._allocation[key] + numberOfTasks
            cumulLength = cumulLength + numberOfTasks
        # 3rd allocation: add the residue task to a computer
        if cumulLength != tasksLength:
            residue = tasksLength - cumulLength
            self._allocation[key] = self._allocation[key] + residue
        print('{} tasks will be splited into {} partitions based on computing power'
              .format(len(tasks), len(self._nodes)))
        self._allocate(tasks)

    def _calculateQuota(self):
        totalPower = sum([1/v for v in self._timeRatio.values()])
        for (key, value) in self._timeRatio.items():
            self._quota[key] = (1/value) / totalPower

    def _allocate(self, tasks):
        # allocate tasks to computers
        for (key, value) in self._allocation.items():
            chunk = tasks[:value]
            tasks = tasks[value:]
            self.setIndividually(key, chunk)

    def show(self):
        for (key, value) in self._nodes.items():
            print('|- {} refers to a {} of length {}'.format(key,type(value),
                  self._length[key]))

    def resume(self, programName='TurbSim', outputFileSize=70*1024**2):
        print("========== Resume Mode ==========")
        oldTasks = self._nodes.get(self._currentComputer)
        if programName.lower() == 'TurbSim'.lower():
            outputList = self._find(self.windPath, '*.bts', outputFileSize)
            inputList = ['{}_{}mps_{}'.format(s[0], s[1], s[2]) for s in self._nodes.get(self._currentComputer)]
            recompute = list(set(inputList).difference(set(outputList)))
            self._nodes[self._currentComputer] = self._convertToSeed(recompute)
            self._length[self._currentComputer] = len(self._nodes[self._currentComputer])
        newTasks = self._nodes.get(self._currentComputer)
        print("{} tasks were affected to this computer, {} tasks haven't been "
              "finished".format(len(oldTasks), len(newTasks)))
 
    def _convertToSeed(self, list_filebase):
        result = []
        for filebase in list_filebase:
            seed = filebase.split('_')
            if len(seed) < 3: continue
            seed[1] = seed[1].rstrip('mps')
            result.append(seed)
        return result

    def _find(self, path, pattern, size):
        ''' size: minimum size in bytes (1 GB = 1024 MB = 1024^2 KB = 1024^3 Bytes) [num]
        '''
        with utils.cd(path):
            p = Path().expanduser()
            matched = sorted(p.glob(pattern))
            if size is None:
                result = [x.stem for x in matched]
            else:
                result = [x.stem for x in matched if x.stat().st_size >= size]
        return result

    def run(self, function, *args):
        if self.echo:
            print('You are running on computer {}'.format(self._currentComputer))
            print('Function {} will be called {} times'.format(function,
                  self._length.get(self._currentComputer)))
            print('========== Computing Starts ==========')
        # execution
        if self._nodes.get(self._currentComputer) is None:
            raise Exception("|- [ERROR] The computer {} is an unknown device".format(
                            self._currentComputer))
        else:
            tasks = self._nodes.get(self._currentComputer)
            #TEMPO save tasks to a file
            # encode = json.dumps(tasks, indent=4)
            # p = Path(self.windPath).parent.expanduser().joinpath('recomputeSeeds7050.json')
            # p.open('w').write(encode)
            # return
            if len(args) == 0: function(tasks)
            if len(args) == 1: function(tasks, args[0])
            if len(args) == 2: function(tasks, args[0], args[1])
            if len(args) == 3: function(tasks, args[0], args[1], args[2])
            if len(args) == 4: function(tasks, args[0], args[1], args[2], args[3])



#!------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!------------------------------------------------------------------------------



#!------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!------------------------------------------------------------------------------
def main():
    test = LMN()
    tasks=[1]*10
    test.setAutomatically(tasks)
    # test.show()



#!------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
