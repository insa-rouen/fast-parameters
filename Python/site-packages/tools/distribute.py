#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Distribute computing tasks
#
#
# Authors: Hao BAI
# Date: 01/11/2018
#
# Version:
#   - 0.0: Initial version
#   - 0.1: Valid version
#   - 0.2: Split tasks according to a fixed ratio based on computing power
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import platform


#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class LMN(object):
    ''' Computers in Laboratoire de Mécanique de Normandie
        Attributes:
            nodes: available computer names [list]
        Methods:
            get(): get tasks by channel name or channel number
    '''
    def __init__(self, function, echo=True):
        self.function = function
        self.echo = echo
        self._nodes = {'PC-LMR-O7010B':[1], # Hao BAI
                       'PC-LMN-7050':[2], # Chao REN
                       'PC-LMN-7040':[3],
                       'PC-LMN-9010':[4], # Changwu HUANG
                       'PC-LMN-1600A':[5], # Surke ALJAMEL
                       'PC-LMN-1600B':[6], # Corentin LOTHODE
                       'PC-LMN-9020':[7], # Shubiao WANG
                     }
        self._ratio = {'PC-LMR-O7010B':0.136, # Hao BAI
                       'PC-LMN-7050':0.171, # Chao REN
                       'PC-LMN-7040':0.173,
                       'PC-LMN-9010':0.105, # Changwu HUANG
                       'PC-LMN-1600A':0.139, # Surke ALJAMEL
                       'PC-LMN-1600B':0.141, # Corentin LOTHODE
                       'PC-LMN-9020':0.135, # Shubiao WANG
                      }
        self._timePerTask = {'PC-LMR-O7010B':89.63, # Hao BAI
                             'PC-LMN-7050':71.44, # Chao REN
                             'PC-LMN-7040':71.19,
                             'PC-LMN-9010':115.38, # Changwu HUANG
                             'PC-LMN-1600A':88.75, # Surke ALJAMEL
                             'PC-LMN-1600B':88.38, # Corentin LOTHODE
                             'PC-LMN-9020':89.88, # Shubiao WANG
                            }
        self._length = dict.fromkeys(self._nodes.keys(), None)
        self._allocation = dict.fromkeys(self._nodes.keys(), None)
        self._currentComputer = platform.node()

        if self.echo:
            print('Distributed Computing v0.2 (November 1 2018)')
            print('========== Pre-processing ==========')

    def setIndividually(self, computerName, tasks):
        self._nodes[computerName] = tasks
        self._length[computerName] = len(tasks)
        estimateTime = self._timePerTask[computerName] * self._length[computerName]
        formatedTime = utils.format_seconds(estimateTime)
        print('|- {} tasks are affected to computer {} and wished to terminate in {}'
              .format(self._length[computerName], computerName, formatedTime))

    def setEqually(self, tasks):
        tasksLength = len(tasks)
        chunkLength = int(tasksLength/len(self._nodes))
        for key in self._nodes.keys():
            self._allocation[key] = chunkLength
        # add the residue task to the most powerful computer
        cumulLength = len(self._nodes) * chunkLength
        if cumulLength != tasksLength:
            residue = tasksLength - cumulLength
            self._allocation['PC-LMN-7040'] = self._allocation['PC-LMN-7040'] + residue
        print('{} tasks will be equally splited into {} partitions'.format(tasksLength,
              len(self._nodes)))
        self._allocate(tasks)

    def setAutomatically(self, tasks):
        # divide tasks into partitions
        tasksLength = len(tasks)
        cumulLength = 0
        for key in self._nodes.keys():
            numberOfTasks = int(round(tasksLength*self._ratio[key],0))
            self._allocation[key] = numberOfTasks
            cumulLength = cumulLength + numberOfTasks
        # add the residue task to the most powerful computer
        if cumulLength != tasksLength:
            residue = tasksLength - cumulLength
            self._allocation['PC-LMN-7040'] = self._allocation['PC-LMN-7040'] + residue
        print('{} tasks will be splited into {} partitions based on computing power'
              .format(tasksLength, len(self._nodes)))
        self._allocate(tasks)

    def _allocate(self, tasks):
        # allocate tasks to computers
        for (key, value) in self._allocation.items():
            chunk = tasks[:value]
            tasks = tasks[value:]
            self.setIndividually(key, chunk)

    def show(self):
        for (key, value) in self._nodes.items():
            print('|- {} refers to a {} of length {}'.format(key,type(value),
                  self._length[key]))

    def run(self):
        if self.echo:
            print('You are running on computer {}'.format(self._currentComputer))
            print('Function {} will be called {} times'.format(self.function,
                  self._length.get(self._currentComputer)))
            print('========== Computing Starts ==========')
        # execution
        if self._nodes.get(self._currentComputer) is None:
            raise Exception("|- [ERROR] The computer {} is an unknown device".format(
                            self._currentComputer))
        else:
            self.function(self._nodes.get(self._currentComputer))



#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
def testFunction():
    pass



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    test = LMN(testFunction)
    test.show()



#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
