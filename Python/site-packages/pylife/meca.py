#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# POST-TRAITEMENT: CALCUL DU CHAMP DE CONTRAINTE
# Sortir l'état de contrainte à partir de résultats obtenus sous FAST, puis réécrire les
# contraintes dans le fichier .str
#
#
# Authors: Hao BAI
# Date: 24/04/2018
#
# Version:
#   - 0.0: only applicable to a annulus secion (that is to say Igx=Igy)
#   - 0.1: [20/05/2018] write stress in MPa, reform data class structure
#   - 0.2: [18/06/2018] upgrade codes to Python3
#   - 0.3: [19/10/2018] reformat the codes so that can be used as a package
#   - 0.4: [25/10/2018] add some comments
#
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import csv
import math
import numpy
import multiprocessing
import collections
from math import sin, cos, radians



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class Stress(object):
    ''' I/O FAST result file .out
    
        *ATTRIBUTES*
            filebase: filename of FAST output file without extension [str]
            datarow: number of line to importing data [int]
            gage: list of tower gage numbers [list]
            thetaStep: different angle between two spots [float]
            mber of the row which has the channel titles [int]
            echo: show results on screen [True/False]
    '''
    def __init__(self, filebase, datarow, gage, thetaStep, echo):
        self.filebase = filebase
        self.datarow = datarow
        self.gage = gage
        self.thetaStep = thetaStep
        self.echo = echo
        # other attributes        
        self.filenameInput = self.filebase + '.out'
        self.filenameOutput = self.filebase + '.str'
        self.listOfTheta = []    
        self.dataInput = dict.fromkeys(self.gage)
        self.stressField = dict.fromkeys(self.gage)
        self.section = dict.fromkeys(self.gage)
        self.dataOutput = collections.deque()
        # calculate stress spot by spot, gage by gage
        self.run()

    def run(self):
        if self.echo: print("Nominal stress v0.4 (October 25 2018)")
        self.geometry()
        if self.echo: print("|- Importing {} ...".format(self.filenameInput))
        self.open()
        if self.echo: print("|- Calculating the nominal stress ...")
        self.calculate(self.thetaStep)
        if self.echo: print("|- Saving data ...")
        self.save()

    def geometry(self):
        ''' Calculate section properties along all tower gages
        '''
        self.NTwGages = 9
        self.TwrGagNd = [1,2,3, 7, 10,11, 15, 19,20] # import from Elastody.dat
        self.TwrNodes = 20
        self.TowerBsHt = 0.0 # [m]
        self.TwrDraft = 0.0 # [m]
        self.TwrElevation = [0.00, 8.76, 17.52, 26.28, 35.04, 43.80, 52.56, 61.32, 70.08,
                             78.84, 87.60] # [m]
        self.TowerHt = self.TwrElevation[-1]
        self.outerDiameter = [6.0000, 5.7870, 5.5740, 5.3610, 5.1480, 4.9350, 4.7220,
                              4.5090, 4.2960, 4.0830, 3.8700] # [m]
        self.thickness = [0.03510, 0.03406, 0.03302, 0.03198, 0.03094, 0.02990, 0.02886,
                          0.02782, 0.02678, 0.02574, 0.02470]
        self.innerDiameter = [i[0]-2*i[1] for i in zip(self.outerDiameter,self.thickness)]
        # calculate section property
        for i in self.gage:
            elevation, outerR, area, inertia, TwrNodeNo = self.__property(i)
            self.section[i] = {'TwrNodeNo':TwrNodeNo, 'z':elevation, 'Re':outerR,
                               'A':area, 'Igx':inertia, 'Igy':inertia}
        # print the geometry information of strain gages
        if self.echo is True:
            print("   ===== Tower geometry and Cross section infomation =====   ")
            print("Tower height :", self.TowerHt, "m")
            print("Total tower nodes :", self.TwrNodes)
            print("Total strain gage locations :", self.NTwGages)
            print(" Gage n° | Tower node n° | Elevation(m) | Outer Radius(m) |",
                  "Area(m2) | 2nd moment of inertia(m4) ")
            for i in self.gage:
                print("{0:^9d}|{1:^15d}|{2:^14.2f}|{3:^17.4f}|{4:^10.4f}|{5:^27.4f}"
                     .format(i, self.section[i]['TwrNodeNo'], self.section[i]['z'], 
                      self.section[i]['Re'],self.section[i]['A'],self.section[i]['Igx'],))

    def __property(self, i):
        ''' Calculate section property
            *INPUT*
                i: tower gage number (value should be between 1 and 9) [int]
        '''
        j = self.TwrGagNd[i-1]
        elevation = self.TowerBsHt + \
                    (j-0.5) * (self.TowerHt+self.TwrDraft-self.TowerBsHt)/self.TwrNodes
        innerD = numpy.interp(elevation, self.TwrElevation, self.innerDiameter)
        outerD = numpy.interp(elevation, self.TwrElevation, self.outerDiameter)
        outerR = outerD/2
        area = math.pi*(outerD**2-innerD**2)/4
        inertia = (outerD**4-innerD**4)*math.pi/64
        return elevation, outerR, area, inertia, j

    def open(self,):
        ''' Read data from .out file
        '''
        temp = utils.readcsv(filename=self.filenameInput, datarow=self.datarow)
        self.dataInput['Time'] = temp.get('Time')['Records']
        for i in self.gage: # force and moment on each node
            self.dataInput[i] = {'FLzt':[], 'MLxt':[], 'MLyt':[]}
            self.dataInput[i]['FLzt'] = temp.get('TwHt'+str(i)+'FLzt')['Records']
            self.dataInput[i]['MLxt'] = temp.get('TwHt'+str(i)+'MLxt')['Records']
            self.dataInput[i]['MLyt'] = temp.get('TwHt'+str(i)+'MLyt')['Records']
        self.dataLength = len(self.dataInput[i]['FLzt'])
        if self.echo:
            print("|- {} lines of data have been imported from {}".format(self.dataLength,
                  self.filenameInput))

    def calculate(self, thetaStep):
        ''' Calculate mechanical stress over all spots
        '''
        self.__stressField(thetaStep)
        self.__writeToRow()

    def __stressField(self, thetaStep):
        ''' Evaluate mechanical stress in time domain
        '''
        self.listOfTheta = tuple(range(0, 360, thetaStep))
        for i in self.gage: # i: the number of gage node
            self.stressField[i] = dict.fromkeys(range(self.dataLength))
            for j in range(self.dataLength): # j: the number of line in input file (time)
                self.stressField[i][j] = {}
                for theta in self.listOfTheta: # theta: angle of spot on this section
                    self.stressField[i][j][theta] = self.__stress(i,j,theta)        
    
    def __stress(self, i, j, theta):
        ''' Calculate the stress
            *INPUT*
                i: the number of gage node
                j: the number of line in input file (time)
                theta: the stress location
        '''
        x = self.section[i]['Re'] * cos(radians(theta))
        y = self.section[i]['Re'] * sin(radians(theta))
        stress = self.dataInput[i]['FLzt'][j] / self.section[i]['A'] \
                 - self.dataInput[i]['MLxt'][j]*y / self.section[i]['Igx'] \
                 + self.dataInput[i]['MLyt'][j]*x / self.section[i]['Igy']
        stress = stress / 1000. # convert stress into MPa
        return stress

    def __writeToRow(self):
        ''' Prepare the row that will be written
        '''
        for j in range(self.dataLength):
            row = {}
            row['Time      '] = str("{:>10.4f}").format(self.dataInput['Time'][j])
            for i in self.gage:
                for theta in self.listOfTheta:
                    header = str("TwHt{0}@{1:<4d}").format(i, theta)
                    row[header] = str("{:>10.3E}").format(self.stressField[i][j][theta])
            self.dataOutput.append(row)

    def save(self):
        ''' Save data to file
        '''
        # Create the title line
        fieldNameOutput = []
        fieldNameOutput.append('Time      ')
        for i in self.gage:
            for theta in self.listOfTheta:
                header = str("TwHt{0}@{1:<4d}").format(i, theta)
                fieldNameOutput.append(header)
        # Create the unit line
        fieldUnitOutput = dict.fromkeys(fieldNameOutput, "{:^10}".format("(MPa)"))
        fieldUnitOutput['Time      '] = "{:^10}".format("(s)")
        # Save result to the file
        with open(self.filenameOutput, 'wt') as f:
            # write something before data (licens, instructions, explanations, etc.)
            f.write('Evaluation of mechanical stress from FAST output file (.out)\n')
            f.write('\n')
            f.write('The output file imported is {}\n'.format(self.filenameInput))
            f.write('The stress is evaluated on tower gage(s) {} corresponding to tower '\
                    'node(s) {} at an elevation of {} meters\n'.format(self.gage,
                    [self.section[i]['TwrNodeNo'] for i in self.gage],
                    [self.section[i]['z'] for i in self.gage]))
            f.write('{:.0f} spots are created on every tower gage with an angle of {} '\
                    'degrees between each other\n'.format(360/self.thetaStep,
                    self.thetaStep))
            f.write('\n')
            # prepare csv writer
            datawriter = csv.DictWriter(f, delimiter='\t', fieldnames=fieldNameOutput)
            datawriter.writeheader() # channel titles
            datawriter.writerow(fieldUnitOutput) # channel units
            for row in self.dataOutput: # channel data
                datawriter.writerow(row)



#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
def get_stress(filebase, datarow, gage, thetaStep=30, echo=False):
    temp = Stress(filebase=filebase, datarow=datarow, gage=gage, thetaStep=thetaStep,
                  echo=echo)

def get_stress_multiprocess(list_filebase, datarow, gage, thetaStep=30, echo=False):
    pool = multiprocessing.Pool()
    [pool.apply_async(get_stress, args=(filebase, datarow, gage, thetaStep, echo),
     error_callback=utils.handle_error) for filebase in list_filebase]
    pool.close()
    pool.join()



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
@utils.timer
def main():
    # mydata = Stress(filebase='DLC1.2_NTM_25mps', datarow=6009, gage=[1,9], thetaStep=30,
    #                 echo=False)
    get_stress_multiprocess(['DLC1.2_NTM_25mps',], 6009, [1,9], thetaStep=30, echo=True)



#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
