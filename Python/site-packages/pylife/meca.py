#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# POST-TRAITEMENT: CALCUL DU CHAMP DE CONTRAINTE
# Sortir l'état de contrainte à partir de résultats obtenus sous FAST, puis réécrire les
# contraintes dans le fichier .str
#
#
# Authors: Hao BAI
# Date: 24/04/2018
#
# Version:
#   - 0.0: only applicable to a annulus secion (that is to say Igx=Igy)
#   - 0.1: [20/05/2018] write stress in MPa, reform data class structure
#   - 0.2: [18/06/2018] upgrade codes to Python3
#   - 0.3: [19/10/2018] reformat the codes so that can be used as a package
#   - 0.4: [25/10/2018] add some comments
#   - 0.5: [05/11/2018] create a supervising function for multiprocess
#   - 0.6: [07/11/2018] user can now choose if save stress file to disk (.str)
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import csv
import math
import time
import numpy
import pandas
import multiprocessing
import collections
from math import sin, cos, radians
from pathlib import Path


#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class Stress(object):
    ''' I/O FAST result file .out
    
        *ATTRIBUTES*
            filebase: filename of FAST output file without extension [str]
            datarow: number of line to importing data [int]
            gages: list of tower gages numbers [list]
            thetaStep: different angle between two spots [float]
            mber of the row which has the channel titles [int]
            echo: show results on screen [True/False]
    '''
    def __init__(self, filebase, datarow, gages, thetaStep, saveToDisk, echo):
        self.filebase = filebase
        self.datarow = datarow
        self.gages = gages
        self.thetaStep = thetaStep
        self.saveToDisk = saveToDisk
        self.echo = echo
        # other attributes
        self.filenameInput = self.filebase + '.out'
        self.filenameOutput = self.filebase + '.str'
        self.listOfTheta = []
        self.dataInput = dict.fromkeys(self.gages)
        self.stressField = dict.fromkeys(self.gages)
        self.section = dict.fromkeys(self.gages)
        self.dataOutput = collections.deque()
        self.logPath = Path('~/Eolien/Parameters/Python/DLC1.1/log')
        self.logPath = self.logPath.expanduser()
        # calculate stress spot by spot, gage by gage
        try:
            self.run()
        except pandas.errors.ParserError as error:
            errorMessage = str(error)
            wrong = True
        except Exception as e:
            raise e
        else:
            wrong = False
        if wrong:
            self.logPath.mkdir(exist_ok=True) # create new folder if non-exist
            filename = self.logPath.joinpath('{}.Sress.bug'.format(self.filebase))
            filename.write_text(errorMessage)
            utils.add_failed_seeds('Stress', self.filebase)
            raise Exception('|- [ERROR] meca.Stress has an error for simulation {}, please see report in {}'.format(self.filebase, filename))
    
    def run(self):
        if self.echo: print("Nominal stress v0.6 (November 7 2018)")
        self.geometry()
        if self.echo: print("|- Importing {} ...".format(self.filenameInput))
        self.open()
        if self.echo: print("|- Calculating the nominal stress ...")
        self.calculate(self.thetaStep)
        if self.echo: print("|- Saving data ...")
        if self.saveToDisk:
            self.save()
        else:
            self.__convertToInputFormat()

    def geometry(self):
        ''' Calculate section properties along all tower gages
        '''
        self.NTwGages = 9
        self.TwrGagNd = [1,2,3, 7, 10,11, 15, 19,20] # import from Elastody.dat
        self.TwrNodes = 20
        self.TowerBsHt = 0.0 # [m]
        self.TwrDraft = 0.0 # [m]
        self.TwrElevation = [0.00, 8.76, 17.52, 26.28, 35.04, 43.80, 52.56, 61.32, 70.08,
                             78.84, 87.60] # [m]
        self.TowerHt = self.TwrElevation[-1]
        self.outerDiameter = [6.0000, 5.7870, 5.5740, 5.3610, 5.1480, 4.9350, 4.7220,
                              4.5090, 4.2960, 4.0830, 3.8700] # [m]
        self.thickness = [0.03510, 0.03406, 0.03302, 0.03198, 0.03094, 0.02990, 0.02886,
                          0.02782, 0.02678, 0.02574, 0.02470]
        self.innerDiameter = [i[0]-2*i[1] for i in zip(self.outerDiameter,self.thickness)]
        # calculate section property
        for i in self.gages:
            elevation, outerR, area, inertia, TwrNodeNo = self.__property(i)
            self.section[i] = {'TwrNodeNo':TwrNodeNo, 'z':elevation, 'Re':outerR,
                               'A':area, 'Igx':inertia, 'Igy':inertia}
        # print the geometry information of strain gages
        if self.echo is True:
            print("   ===== Tower geometry and Cross section infomation =====   ")
            print("Tower height :", self.TowerHt, "m")
            print("Total tower nodes :", self.TwrNodes)
            print("Total strain gage locations :", self.NTwGages)
            print(" Gage n° | Tower node n° | Elevation(m) | Outer Radius(m) |",
                  "Area(m2) | 2nd moment of inertia(m4) ")
            for i in self.gages:
                print("{0:^9d}|{1:^15d}|{2:^14.2f}|{3:^17.4f}|{4:^10.4f}|{5:^27.4f}"
                     .format(i, self.section[i]['TwrNodeNo'], self.section[i]['z'], 
                      self.section[i]['Re'],self.section[i]['A'],self.section[i]['Igx'],))

    def __property(self, i):
        ''' Calculate section property
            *INPUT*
                i: tower gage number (value should be between 1 and 9) [int]
        '''
        j = self.TwrGagNd[i-1]
        elevation = self.TowerBsHt + \
                    (j-0.5) * (self.TowerHt+self.TwrDraft-self.TowerBsHt)/self.TwrNodes
        innerD = numpy.interp(elevation, self.TwrElevation, self.innerDiameter)
        outerD = numpy.interp(elevation, self.TwrElevation, self.outerDiameter)
        outerR = outerD/2
        area = math.pi*(outerD**2-innerD**2)/4
        inertia = (outerD**4-innerD**4)*math.pi/64
        return elevation, outerR, area, inertia, j

    def open(self,):
        ''' Read data from .out file
        '''
        temp = utils.readcsv(filename=self.filenameInput, datarow=self.datarow,
                             echo=self.echo)
        self.dataInput['Time'] = temp.get('Time')['Records']
        for i in self.gages: # force and moment on each node
            self.dataInput[i] = {'FLzt':[], 'MLxt':[], 'MLyt':[]}
            self.dataInput[i]['FLzt'] = temp.get('TwHt'+str(i)+'FLzt')['Records']
            self.dataInput[i]['MLxt'] = temp.get('TwHt'+str(i)+'MLxt')['Records']
            self.dataInput[i]['MLyt'] = temp.get('TwHt'+str(i)+'MLyt')['Records']
        self.dataLength = len(self.dataInput[i]['FLzt'])
        if self.echo:
            print("|- {} lines of data have been imported from {}".format(self.dataLength,
                  self.filenameInput))

    def calculate(self, thetaStep):
        ''' Calculate mechanical stress over all spots
        '''
        self.__stressField(thetaStep)

    def __stressField(self, thetaStep):
        ''' Evaluate mechanical stress in time domain
        '''
        self.listOfTheta = tuple(range(0, 360, thetaStep))
        for i in self.gages: # i: the number of gage node
            self.stressField[i] = dict.fromkeys(range(self.dataLength))
            for j in range(self.dataLength): # j: the number of line in input file (time)
                self.stressField[i][j] = {}
                for theta in self.listOfTheta: # theta: angle of spot on this section
                    self.stressField[i][j][theta] = self.__stress(i,j,theta)        
    
    def __stress(self, i, j, theta):
        ''' Calculate the stress
            *INPUT*
                i: the number of gage node
                j: the number of line in input file (time)
                theta: the stress location
        '''
        x = self.section[i]['Re'] * cos(radians(theta))
        y = self.section[i]['Re'] * sin(radians(theta))
        stress = self.dataInput[i]['FLzt'][j] / self.section[i]['A'] \
                 - self.dataInput[i]['MLxt'][j]*y / self.section[i]['Igx'] \
                 + self.dataInput[i]['MLyt'][j]*x / self.section[i]['Igy']
        stress = stress / 1000. # convert stress into MPa
        return stress

    def __convertToInputFormat(self):
        ''' Convert result to utils.Input instance
        '''
        result = utils.Input()
        for i in self.gages:
            for theta in self.listOfTheta:
                header = "TwHt{}@{}".format(i, theta)
                result.data[header] = {'Records':[]}
                result.data[header]['Records'] = [self.stressField[i][j][theta] for j in range(self.dataLength)]
        self.dataOutput = result

    def __convertToCSVFormat(self):
        ''' Prepare the row that will be written in csv-like file
        '''
        for j in range(self.dataLength):
            row = {}
            row['Time      '] = str("{:>10.4f}").format(self.dataInput['Time'][j])
            for i in self.gages:
                for theta in self.listOfTheta:
                    header = str("TwHt{0}@{1:<4d}").format(i, theta)
                    row[header] = str("{:>10.3E}").format(self.stressField[i][j][theta])
            self.dataOutput.append(row)
    
    def save(self):
        ''' Save data to file
        '''
        self.__convertToCSVFormat()
        # Create the title line
        fieldNameOutput = []
        fieldNameOutput.append('Time      ')
        for i in self.gages:
            for theta in self.listOfTheta:
                header = str("TwHt{0}@{1:<4d}").format(i, theta)
                fieldNameOutput.append(header)
        # Create the unit line
        fieldUnitOutput = dict.fromkeys(fieldNameOutput, "{:^10}".format("(MPa)"))
        fieldUnitOutput['Time      '] = "{:^10}".format("(s)")
        # Save result to the file
        with open(self.filenameOutput, 'wt') as f:
            # write something before data (licens, instructions, explanations, etc.)
            f.write('Evaluation of mechanical stress from FAST output file (.out)\n')
            f.write('\n')
            f.write('The output file imported is {}\n'.format(self.filenameInput))
            f.write('The stress is evaluated on tower gage(s) {} corresponding to tower '\
                    'node(s) {} at an elevation of {} meters\n'.format(self.gages,
                    [self.section[i]['TwrNodeNo'] for i in self.gages],
                    [self.section[i]['z'] for i in self.gages]))
            f.write('{:.0f} spots are created on every tower gage with an angle of {} '\
                    'degrees between each other\n'.format(360/self.thetaStep,
                    self.thetaStep))
            f.write('\n')
            # prepare csv writer
            datawriter = csv.DictWriter(f, delimiter='\t', fieldnames=fieldNameOutput)
            datawriter.writeheader() # channel titles
            datawriter.writerow(fieldUnitOutput) # channel units
            for row in self.dataOutput: # channel data
                datawriter.writerow(row)




#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
def get_stress(filebase, datarow, gages, thetaStep=30, saveToDisk=False, echo=False):
    result = Stress(filebase=filebase, datarow=datarow, gages=gages, thetaStep=thetaStep,
                  saveToDisk=saveToDisk, echo=echo)
    return result

def get_stress_multiprocess(list_filebase, datarow, gages, thetaStep=30, saveToDisk=False,
                            echo=False):
    print('Stress v0.6 (November 7 2018)')
    print('========== Multiprocessing Mode ==========')
    # prepare a callback function
    length = len(list_filebase)
    completed = []
    def printer(stress):
        pos = list_filebase.index(stress.filebase) + 1
        completed.append(stress.filebase)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] Mechanical stress of {} is saved to disk at {}:{}. {} tasks'
              ' waiting to be completed ...'.format(pos, length, stress.filebase, hour,
              minute, rest))
    # begin multiprocessing
    pool = multiprocessing.Pool()
    [pool.apply_async(get_stress, args=(filebase, datarow, gages, thetaStep, saveToDisk,
     echo), callback=printer, error_callback=utils.handle_error) for filebase in
     list_filebase]
    pool.close()
    pool.join()



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
@utils.timer
def main():
    # mydata = Stress(filebase='DLC1.2_NTM_25mps', datarow=6009, gages=[1,9], thetaStep=30,
    #                 echo=False)
    # get_stress('DLC1.2_NTM_25mps', 6009, [1,2,3,4,5,6,7,8,9], 'a', saveToDisk=True, echo=False)
    # get_stress_multiprocess(['DLC1.2_NTM_25mps',], 6009, [1,9], thetaStep=30,
    #                         saveToDisk=False, echo=True)

    # Test error control
    seeds = ['NTM_3mps_-544599383', 'NTM_5mps_1571779345']
    with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Output/DLC1.1/'):
        get_stress(seeds[1], 6009, [1,2,3,4,5,6,7,8,9], 'a', saveToDisk=False, echo=True)
        # get_stress_multiprocess(seeds, 6009, [1,9], thetaStep=30, saveToDisk=False, echo=True)



#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
