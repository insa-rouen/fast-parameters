#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# FATIGUE LIFE ASSESSMENT
# Sortir l'état de contrainte à partir de résultats obtenus sous FAST, puis réécrire les
# contraintes dans le fichier .str
#
#
# Authors: Hao BAI
# Date: 19/10/2018
#
# Version:
#   - 0.0: get S-N curves with Goodman correction (retrieve ancient sn.py)
#   - 0.1: Rainflow counting (retrieve ancient count.py)
#   - 0.2：assess lifetime cumulative damage (retrieve ancient fatigue.py)
#   - 0.3: improve performance by isolating the codes of Goodman correction
#
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import collections
from math import log10
import rainflow
import multiprocessing
import json


#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class DNVGL(object):
    ''' DNVGL-RP-C203 (Edition April 2016)
        << Recommended Practice - Fatigue design of offshore steel structures >>
        *ATTRIBUTES*
            SNcurve : DNVGL notation of S-N curve [str]
            air : S-N curves in air (True: in air; False: in seawater) [True]
            cp : cathodic protection (only valide in seawater) [False]
            Goodman : Goodman correction [False]
    '''
    def __init__(self, SNcurve, air=True, cp=False, Goodman=(False, 0.0), materialID='',
                 echo=False):
        self.SNcurve = SNcurve
        self.air = air
        self.cp = cp
        self.Goodman = Goodman
        self.materialID = materialID
        self.echo = echo
        # internal attributes
        self.material = None
        self.__materials = dict.fromkeys(('C','C-Mn'))
        self.__curves = dict.fromkeys(('B1', 'B2', 'C', 'C1', 'C2', 'D', 'E', 'F', 'F1',
                                       'F3','G','W1', 'W2', 'W3'))
        # get SN curve from database
        self.run()

    def run(self):
        if self.echo: print("S-N curve v0.1 (October 25 2018)")
        self.__build()
        self.__choose()

    def __build(self):
        ''' Build database
        '''
        # §1.2.1 steel forgings in air, page 9
        # Table D-1 Design S-N curves for steel forgings in air, page 168
        # Rm : ultimate tensile strength = résistance à la traction (MPa)
        # Re : yield strength = limite d'élasticité (MPa)
        record = collections.namedtuple('Material', 'Rm_air, Re_air, Rm_sea, Re_sea')
        self.__materials['C'] = record(862, 724, 793, 689)
        self.__materials['C-Mn'] = record(None, 960, None, 690)
        # Table 2-1 S-N curves in air, page 23
        # m : negative inverse slope of S-N curve
        # a : intercept of log N-axis by S-N curve
        # N : number of cycles to failure at fatigue limite = 10^7
        # Sf : fatigue limite at 10^7 cycles (MPa)
        record = collections.namedtuple('SNcurve', ('air, cp, m1, a1, m2, a2, N, Sf, k, SCF'))
        self.__curves['B1'] = record(True, None, 4.0, 15.117, 5.0, 17.146, 1e7, 106.97, 0.00, None)
        self.__curves['B2'] = record(True, None, 4.0, 14.885, 5.0, 16.856, 1e7,  93.59, 0.00, None)
        self.__curves['C']  = record(True, None, 3.0, 12.592, 5.0, 16.320, 1e7,  73.10, 0.05, None)
        self.__curves['C1'] = record(True, None, 3.0, 12.449, 5.0, 16.081, 1e7,  65.50, 0.10, None)
        self.__curves['C2'] = record(True, None, 3.0, 12.301, 5.0, 15.835, 1e7,  58.48, 0.15, None)
        self.__curves['D']  = record(True, None, 3.0, 12.164, 5.0, 15.606, 1e7,  52.63, 0.20, 1.00)
        self.__curves['E']  = record(True, None, 3.0, 12.010, 5.0, 15.350, 1e7,  46.78, 0.20, 1.13)
        self.__curves['F']  = record(True, None, 3.0, 11.855, 5.0, 15.091, 1e7,  41.52, 0.25, 1.27)
        self.__curves['F1'] = record(True, None, 3.0, 11.699, 5.0, 14.832, 1e7,  36.84, 0.25, 1.43)
        self.__curves['F3'] = record(True, None, 3.0, 11.546, 5.0, 14.576, 1e7,  32.75, 0.25, 1.61)
        self.__curves['G']  = record(True, None, 3.0, 11.398, 5.0, 14.330, 1e7,  29.24, 0.25, 1.80)
        self.__curves['W1'] = record(True, None, 3.0, 11.261, 5.0, 14.101, 1e7,  26.32, 0.25, 2.00)
        self.__curves['W2'] = record(True, None, 3.0, 11.107, 5.0, 13.845, 1e7,  23.39, 0.25, 2.25)
        self.__curves['W3'] = record(True, None, 3.0, 10.970, 5.0, 13.617, 1e7,  21.05, 0.25, 2.50)

    def __choose(self):
        ''' Select S-N curve
        '''
        # Without Goodman correction
        curve = self.__curves.get(self.SNcurve)
        if curve is None:
            raise Exception("[Error] No such S-N curve !")
        else:
            self.curveRef = curve
        # With Goodman correction: by using ultimate tensile strength
        if self.Goodman[0] is True:
            # Get material
            if self.materialID is '':
                self.material = self.__materials.get('C') # default material
            else:
                self.material = self.__materials.get(self.materialID)
                if self.material is None:
                    raise Exception("[Error] No such material !")
            self.change_Goodman(self.Goodman[1])

    def change_Goodman(self, meanStress):
        ''' Change S-N curve by applying mean stress from Rainflow counting
        '''
        # Sfa : alternating stress (MPa)
        if self.air is True:
            Sfa = self.curveRef.Sf * (1 - meanStress/self.material.Rm_air)
        else:
            Sfa = self.curveRef.Sf * (1 - meanStress/self.material.Rm_sea)
        # Change a1 and a2
        a1 = log10(self.curveRef.N) + self.curveRef.m1*log10(Sfa)
        a2 = log10(self.curveRef.N) + self.curveRef.m2*log10(Sfa)
        self.curveGoodman = self.curveRef._replace(a1=a1, a2=a2, Sf=Sfa)
        return self

    def whichSN(self, stressRange, curveConf):
        if stressRange >= curveConf.Sf:
            N = 10.0**(curveConf.a1 - curveConf.m1*log10(stressRange))
        elif stressRange < curveConf.Sf:
            N = 10.0**(curveConf.a2 - curveConf.m2*log10(stressRange))
        return N

    def sn(self, stressRange):
        if self.Goodman[0] is True:
            return self.whichSN(stressRange, self.curveGoodman)
        else:
            return self.whichSN(stressRange, self.curveRef)
    
    def whichNS(self, cycle, curveConf):
        if cycle <= curveConf.N:
            stressRange = 10.0**((curveConf.a1-log10(cycle))/curveConf.m1)
        elif cycle > curveConf.N:
            stressRange = 10.0**((curveConf.a2-log10(cycle))/curveConf.m2)
        return stressRange

    def ns(self, cycle):
        if self.Goodman[0] is True:
            return self.whichNS(cycle, self.curveGoodman)
        else:
            return self.whichNS(cycle, self.curveRef)

    def plotSN(self):
        ''' Plot S-N curve
        '''
        from matplotlib import pyplot as plt

        X = range(int(1e4), int(1e8+1), int(1e6))
        Y = []
        # Plot S-N curve without Goodman
        [Y.append(self.whichNS(x, self.curveRef)) for x in X]
        plt.loglog(X,Y, 'b', label="S-N curve") # Plot S-N curve
        x_reversal = self.curveRef.N
        y_reversal = self.whichNS(self.curveRef.N, self.curveRef)
        plt.plot(x_reversal, y_reversal, 'b*') # Plot reversal point at 10^7
        coordinates = r"$(10^{0:.0f},{1:.2f})$".format(log10(x_reversal), y_reversal)
        plt.text(x_reversal, y_reversal, coordinates, color='b')

        # Plot S-N curve with Goodman correction
        if self.Goodman[0] is True:
            Y = []
            [Y.append(self.whichNS(x, self.curveGoodman)) for x in X]
            plt.loglog(X,Y, 'r', label="S-N curve with Goodman") # Plot S-N curve
            x_reversal = self.curveGoodman.N
            y_reversal = self.whichNS(self.curveGoodman.N, self.curveGoodman)
            plt.plot(x_reversal, y_reversal, 'r*') # Plot reversal point at 10^7
            coordinates = r"$(10^{0:.0f},{1:.2f})$".format(log10(x_reversal), y_reversal)
            plt.text(x_reversal, y_reversal, coordinates, verticalalignment='top', \
                     horizontalalignment='right', color='r', )

        # Make title, legend, label and so on
        if self.air is True:
            title = "S-N curve : {} in air".format(self.SNcurve)
        elif self.cp is True:
            title = "S-N curve : {} in seawater with cathodic protection".format(self.SNcurve)
        else:
            title = "S-N curve : {} in seawater without cathodic protection".format(self.SNcurve)
        plt.title(title)
        plt.legend()
        plt.xlabel("Number of cycles")
        plt.ylabel("Stress range (MPa)")
        plt.axis([1e4, 1e8, 1e1, 1e3]) # plt.xlim(1e4, 1e8)
        plt.grid(True, which='both') # show 'major', 'minor' or 'both' tick grids
        plt.show()


class Count(object):
    ''' Rainflow counting over every spot on each tower gage
        *ATTRIBUTES*
            filename: filename of mechanical stress file (.str) [str]
            gages: number of tower gages [list]
    '''
    def __init__(self, filebase, gages=None, echo=False):
        self.filebase = filebase
        self.filenameInput = self.filebase + '.str'
        self.gages = gages
        self.echo = echo
        # Input/Output attributes
        self.dataInput = {}
        self.spots = []
        self.rainflowData = {}
        # Run rainflow counting
        self.run()

    def run(self):
        if self.echo: print("Rainflow counting v0.3 (October 25 2018)")
        if self.echo: print("|- Importing {} ...".format(self.filenameInput))
        self.open()
        if self.echo: print("|- Counting Rainflow cycles ...")
        self.count()
        if self.echo: self.show()
        if self.echo: print("|- [OK] Rainflow count finished !")

    def open(self):
        self.dataInput = utils.readcsv(self.filenameInput, unitrow=8, echo=self.echo)
        # Check where to count
        if self.gages is None: # count cycles on every spot over each tower gage
            print("|- [ALERT] Every stress history will be used to count Rainflow",
                  "cycles. If you don't mean it, try to choose serval tower gages in",
                  "order to reduce time consumption")
            allSpots = self.dataInput.getkeys()
            allSpots.pop(0) # remove "Time" column
            self.spots = allSpots
        elif isinstance(self.gages[0], int): # count cycles over given tower gages
            
            available = self.dataInput.getkeys()[1:]
            for name in available:                
                if int(name[4]) in self.gages:
                    self.spots.append(name)
                else:
                    print("|- [ERROR] There is no TwHt{} in input file".format(name[4]))

    def count(self):
        ''' Rainflow counting spot by spot
        '''
        for spot in self.spots:
            self.rainflowData[spot] = {'Cycle':collections.deque(),
                                       'Range':collections.deque(),
                                       'Mean':collections.deque()}
            for valley, peak, cycle in rainflow.extract_cycles(self.dataInput.get(spot)['Records']):
                rangeValue = peak - valley
                meanValue = (peak+valley)/2
                self.rainflowData[spot]['Cycle'].append(cycle)
                self.rainflowData[spot]['Range'].append(rangeValue)
                self.rainflowData[spot]['Mean'].append(meanValue)

    def show(self):
        ''' Showing results on screen
        '''
        for spot in self.spots:
            data = self.rainflowData[spot]
            length = len(data['Cycle'])
            print('========== '+spot+' ==========')
            print('Num. of Cycles','Stress Range (MPa)','Stess Mean (MPa)')
            for i in range(length):
                print(data['Cycle'][i], data['Range'][i], data['Mean'][i])
            print('\n')

class Fatigue(object):
    ''' Calculate cumulative damage
        *ATTRIBUTES*
    '''
    def __init__(self, filebase, gages, lifetime, echo):
        self.filebase = filebase
        self.gages = gages
        self.echo = echo
        # initiate rainflow counting
        try:
            self.RFdata = Count(filebase=filebase, gages=gages, echo=echo)
        except Exception as e:
            print("|- [ERROR] Wrong spot index name or gage node nubmer !")
            raise e
        # initiate S-N curve
        self.curve = DNVGL('B1', Goodman=(True, 0.0))
        # some other attributes
        self.spots = self.RFdata.rainflowData.keys()
        self.damage = dict.fromkeys(self.spots)
        self.lifetime = lifetime # Wind tower's designed lifetime per 10min

    def _assess_damage(self, spot):
        ''' Assess cumulative damage on 1 single spot
        '''
        self.damage[spot] = {'n':collections.deque(), 'N':collections.deque(),
                             'D':collections.deque(), 'Dtotal':0.0, 'Dlife':0.0}
        self.damage[spot]['n'] = self.RFdata.rainflowData[spot]['Cycle']
        ranges = self.RFdata.rainflowData[spot]['Range']
        means = self.RFdata.rainflowData[spot]['Mean']

        # find limit cycle from S-N curve
        for i in range(len(ranges)):
            n = self.damage[spot]['n'][i]
            curve = self.curve.change_Goodman(means[i])
            N = curve.sn(ranges[i])
            self.damage[spot]['N'].append(N)
            D = n/N
            self.damage[spot]['D'].append(D)
            self.damage[spot]['Dtotal'] = self.damage[spot]['Dtotal'] + D

        self.damage[spot]['Dlife'] = self.damage[spot]['Dtotal'] * self.lifetime
        if self.echo:
            print('{}\t{}\t{}'.format(spot, self.damage[spot]['Dtotal'],
                  self.damage[spot]['Dlife']))

    def assess_spots(self):
        ''' Assess cumulative damage over all spots
        '''
        if self.echo:
            print("Spotname\tDamage during simulated time\tDamege during lifetime ( =",
                  "Damage during simulated time * lifetime)")
        list(map(self._assess_damage, self.spots))
        #! map() in Python 3 is LAZY. It won't get called until you ask for the value of
        #! that item in the mapped result, whether by using next() or some other way
        
    def assess_multithread(self):
        ''' Try to make calculationg in parallel
        '''
        # pool = multiprocessing.Pool()
        pool = multiprocessing.pool.ThreadPool(20)
        # [pool.apply_async(self._assess_damage, args=(spot,)) for spot in self.spots]
        pool.map_async(self._assess_damage, self.spots)
        pool.close()
        pool.join()

    def save(self, filebase=None):
        if filebase is None: filename = self.filebase + ".dam"
        outputData = {}
        for key in self.damage.keys():
            outputData[key] = {'Dtotal':self.damage[key]['Dtotal'],
                               'Dlife':self.damage[key]['Dlife']}
        encode = json.dumps(outputData, indent=4)
        with open(filename, 'w') as f:
            f.write(encode)
        print("|- [OK] All cumulative damages are saved to the file", filename)



#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
def get_fatigue(filebase, gages=None, lifetime=20*365*24*6, echo=False):
    temp = Fatigue(filebase=filebase, gages=gages, lifetime=lifetime, echo=echo)
    temp.assess_spots()
    temp.save()

def get_fatigue_multiprocess(list_filebase, gages=None, lifetime=20*365*24*6, echo=False):
    pool = multiprocessing.Pool()
    [pool.apply_async(get_fatigue, args=(filebase, gages, lifetime, echo),
     error_callback=utils.handle_error) for filebase in list_filebase]
    pool.close()
    pool.join()



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
@utils.timer
def main():
    test = 3
    # Testing DNGVL class
    if test == 1:
        curve = DNVGL('B1', Goodman=(True, 20.0))
        # print(curve.sn(curve.ns(1e7)))
        # curve.plotSN()
        # curve = DNVGL('C2')
        # curve.plotSN()
        # print('|- OK')
        curve.change_Goodman(0.0)

    # Testing Count class
    if test == 2:
        # myCount3 = Count('DLC1.2_NTM_25mps', echo=1)
        myCount3 = Count('DLC1.2_NTM_25mps', gages=[1,5,9])

    # Tesint Fatigue class
    if test == 3:
        # analysis = Fatigue('DLC1.2_NTM_25mps', gages=[1,9], lifetime=20*365*24*6, echo=0)
        # analysis.assess_spots()
        # analysis.assess_multithread()
        # analysis._assess_damage('TwHt1@0')
        # analysis.save()
        get_fatigue('DLC1.2_NTM_25mps', [1,9],)


#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
