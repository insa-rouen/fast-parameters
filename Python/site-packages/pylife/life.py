#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# FATIGUE LIFE ASSESSMENT
# Sortir l'état de contrainte à partir de résultats obtenus sous FAST, puis réécrire les
# contraintes dans le fichier .str
#
#
# Authors: Hao BAI
# Date: 19/10/2018
#
# Version:
#   - 0.0: get S-N curves with Goodman correction (retrieve ancient sn.py)
#   - 0.1: Rainflow counting (retrieve ancient count.py)
#   - 0.2：assess lifetime cumulative damage (retrieve ancient fatigue.py)
#   - 0.3: improve performance by isolating the codes of Goodman correction
#   - 0.4: create a supervising function for multiprocess
#   - 0.5: enable fatigue assessment directly from FAST output file (.out)
#   - 1.0: adapt syntax to <package rainflow> v3.0.0
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!------------------------------------------------------------------------------
#*============================= Modules Personnels =============================
from tools import utils
from pylife import meca
#*============================== Modules Communs ==============================
import json
import time
import pandas
import collections
import rainflow
import platform
import multiprocessing
from math import log10
from pathlib import Path



#!------------------------------------------------------------------------------
#!                                         CLASS
#!------------------------------------------------------------------------------
class DNVGL(object):
    ''' DNVGL-RP-C203 (Edition April 2016)
        << Recommended Practice - Fatigue design of offshore steel structures >>
        *ATTRIBUTES*
            SNcurve : DNVGL notation of S-N curve [str]
            air : S-N curves in air (True: in air; False: in seawater) [True]
            cp : cathodic protection (only valide in seawater) [False]
            Goodman : Goodman correction [False]
    '''
    def __init__(self, SNcurve, air=True, cp=False, Goodman=(False, 0.0), materialID='',
                 echo=False):
        self.SNcurve = SNcurve
        self.air = air
        self.cp = cp
        self.Goodman = Goodman
        self.materialID = materialID
        self.echo = echo
        # internal attributes
        self.material = None
        self.__materials = dict.fromkeys(('C','C-Mn'))
        self.__curves = dict.fromkeys(('B1', 'B2', 'C', 'C1', 'C2', 'D', 'E', 'F', 'F1',
                                       'F3','G','W1', 'W2', 'W3'))
        # get SN curve from database
        self.run()

    def run(self):
        if self.echo: print("S-N curve v0.1 (October 25 2018)")
        self.__build()
        self.__choose()

    def __build(self):
        ''' Build database
        '''
        # §1.2.1 steel forgings in air, page 9
        # Table D-1 Design S-N curves for steel forgings in air, page 168
        # Rm : ultimate tensile strength = résistance à la traction (MPa)
        # Re : yield strength = limite d'élasticité (MPa)
        record = collections.namedtuple('Material', 'Rm_air, Re_air, Rm_sea, Re_sea')
        self.__materials['C'] = record(862, 724, 793, 689)
        self.__materials['C-Mn'] = record(None, 960, None, 690)
        # Table 2-1 S-N curves in air, page 23
        # m : negative inverse slope of S-N curve
        # a : intercept of log N-axis by S-N curve
        # N : number of cycles to failure at fatigue limite = 10^7
        # Sf : fatigue limite at 10^7 cycles (MPa)
        record = collections.namedtuple('SNcurve', ('air, cp, m1, a1, m2, a2, N, Sf, k, SCF'))
        self.__curves['B1'] = record(True, None, 4.0, 15.117, 5.0, 17.146, 1e7, 106.97, 0.00, None)
        self.__curves['B2'] = record(True, None, 4.0, 14.885, 5.0, 16.856, 1e7,  93.59, 0.00, None)
        self.__curves['C']  = record(True, None, 3.0, 12.592, 5.0, 16.320, 1e7,  73.10, 0.05, None)
        self.__curves['C1'] = record(True, None, 3.0, 12.449, 5.0, 16.081, 1e7,  65.50, 0.10, None)
        self.__curves['C2'] = record(True, None, 3.0, 12.301, 5.0, 15.835, 1e7,  58.48, 0.15, None)
        self.__curves['D']  = record(True, None, 3.0, 12.164, 5.0, 15.606, 1e7,  52.63, 0.20, 1.00)
        self.__curves['E']  = record(True, None, 3.0, 12.010, 5.0, 15.350, 1e7,  46.78, 0.20, 1.13)
        self.__curves['F']  = record(True, None, 3.0, 11.855, 5.0, 15.091, 1e7,  41.52, 0.25, 1.27)
        self.__curves['F1'] = record(True, None, 3.0, 11.699, 5.0, 14.832, 1e7,  36.84, 0.25, 1.43)
        self.__curves['F3'] = record(True, None, 3.0, 11.546, 5.0, 14.576, 1e7,  32.75, 0.25, 1.61)
        self.__curves['G']  = record(True, None, 3.0, 11.398, 5.0, 14.330, 1e7,  29.24, 0.25, 1.80)
        self.__curves['W1'] = record(True, None, 3.0, 11.261, 5.0, 14.101, 1e7,  26.32, 0.25, 2.00)
        self.__curves['W2'] = record(True, None, 3.0, 11.107, 5.0, 13.845, 1e7,  23.39, 0.25, 2.25)
        self.__curves['W3'] = record(True, None, 3.0, 10.970, 5.0, 13.617, 1e7,  21.05, 0.25, 2.50)

    def __choose(self):
        ''' Select S-N curve
        '''
        # Without Goodman correction
        curve = self.__curves.get(self.SNcurve)
        if curve is None:
            raise Exception("[Error] No such S-N curve !")
        else:
            self.curveRef = curve
        # With Goodman correction: by using ultimate tensile strength
        if self.Goodman[0] is True:
            # Get material
            if self.materialID is '':
                self.material = self.__materials.get('C') # default material
            else:
                self.material = self.__materials.get(self.materialID)
                if self.material is None:
                    raise Exception("[Error] No such material !")
            self.change_Goodman(self.Goodman[1])

    def change_Goodman(self, meanStress):
        ''' Change S-N curve by applying mean stress from Rainflow counting
        '''
        # Sfa : alternating stress (MPa)
        if self.air is True:
            Sfa = self.curveRef.Sf * (1 - meanStress/self.material.Rm_air)
        else:
            Sfa = self.curveRef.Sf * (1 - meanStress/self.material.Rm_sea)
        # Change a1 and a2
        a1 = log10(self.curveRef.N) + self.curveRef.m1*log10(Sfa)
        a2 = log10(self.curveRef.N) + self.curveRef.m2*log10(Sfa)
        self.curveGoodman = self.curveRef._replace(a1=a1, a2=a2, Sf=Sfa)
        return self

    def whichSN(self, stressRange, curveConf):
        if stressRange >= curveConf.Sf:
            N = 10.0**(curveConf.a1 - curveConf.m1*log10(stressRange))
        elif stressRange < curveConf.Sf:
            N = 10.0**(curveConf.a2 - curveConf.m2*log10(stressRange))
        return N

    def sn(self, stressRange):
        if self.Goodman[0] is True:
            return self.whichSN(stressRange, self.curveGoodman)
        else:
            return self.whichSN(stressRange, self.curveRef)
    
    def whichNS(self, cycle, curveConf):
        if cycle <= curveConf.N:
            stressRange = 10.0**((curveConf.a1-log10(cycle))/curveConf.m1)
        elif cycle > curveConf.N:
            stressRange = 10.0**((curveConf.a2-log10(cycle))/curveConf.m2)
        return stressRange

    def ns(self, cycle):
        if self.Goodman[0] is True:
            return self.whichNS(cycle, self.curveGoodman)
        else:
            return self.whichNS(cycle, self.curveRef)

    def plotSN(self):
        ''' Plot S-N curve
        '''
        from matplotlib import pyplot as plt

        X = range(int(1e4), int(1e8+1), int(1e6))
        Y = []
        # Plot S-N curve without Goodman
        [Y.append(self.whichNS(x, self.curveRef)) for x in X]
        plt.loglog(X,Y, 'b', label="S-N curve") # Plot S-N curve
        x_reversal = self.curveRef.N
        y_reversal = self.whichNS(self.curveRef.N, self.curveRef)
        plt.plot(x_reversal, y_reversal, 'b*') # Plot reversal point at 10^7
        coordinates = r"$(10^{0:.0f},{1:.2f})$".format(log10(x_reversal), y_reversal)
        plt.text(x_reversal, y_reversal, coordinates, color='b')

        # Plot S-N curve with Goodman correction
        if self.Goodman[0] is True:
            Y = []
            [Y.append(self.whichNS(x, self.curveGoodman)) for x in X]
            plt.loglog(X,Y, 'r', label="S-N curve with Goodman") # Plot S-N curve
            x_reversal = self.curveGoodman.N
            y_reversal = self.whichNS(self.curveGoodman.N, self.curveGoodman)
            plt.plot(x_reversal, y_reversal, 'r*') # Plot reversal point at 10^7
            coordinates = r"$(10^{0:.0f},{1:.2f})$".format(log10(x_reversal), y_reversal)
            plt.text(x_reversal, y_reversal, coordinates, verticalalignment='top', \
                     horizontalalignment='right', color='r', )

        # Make title, legend, label and so on
        if self.air is True:
            title = "S-N curve : {} in air".format(self.SNcurve)
        elif self.cp is True:
            title = "S-N curve : {} in seawater with cathodic protection".format(self.SNcurve)
        else:
            title = "S-N curve : {} in seawater without cathodic protection".format(self.SNcurve)
        plt.title(title)
        plt.legend()
        plt.xlabel("Number of cycles")
        plt.ylabel("Stress range (MPa)")
        plt.axis([1e4, 1e8, 1e1, 1e3]) # plt.xlim(1e4, 1e8)
        plt.grid(True, which='both') # show 'major', 'minor' or 'both' tick grids
        plt.show()


class Count(object):
    ''' Rainflow counting over every spot on each tower gage
        *ATTRIBUTES*
            filename: filename of mechanical stress file (.str) [str]
            gages: number of tower gages [list]
    '''
    def __init__(self, filebase, gages=None, echo=False):
        self.filebase = filebase
        self.gages = gages
        self.echo = echo
        # other attributes
        self.dataInput = {}
        self.spots = []
        self.rainflowData = {}
        self.logPath = Path('~/Eolien/Parameters/Python/DLC1.1/log')
        self.logPath = self.logPath.expanduser()
        # Run rainflow counting
        try:
            self.run()
        except pandas.errors.ParserError as error:
            errorMessage = str(error)
            wrong = True
        except Exception as e:
            raise e
        else:
            wrong = False
        if wrong:
            self.logPath.mkdir(exist_ok=True) # create new folder if non-exist
            filename = self.logPath.joinpath('{}.Count.bug'.format(self.filebase))
            filename.write_text(errorMessage)
            utils.add_failed_seeds('Count', self.filebase)
            raise Exception('|- [ERROR] life.Count has an error for simulation {}, please see report in {}'.format(self.filebase, filename))

    def run(self):
        if self.echo: print("Rainflow counting v1.0 (Oct. 2020)")
        if self.echo: print("|- Importing {} ...".format(self.filebase))
        self.open()
        if self.echo: print("|- Counting Rainflow cycles ...")
        self.count()
        if self.echo: self.show()
        if self.echo: print("|- [OK] Rainflow count finished !")

    def open(self):
        # Check input data type
        if isinstance(self.filebase, str):
            self.dataInput = utils.readcsv(self.filebase+'.str', unitrow=8,
                                           checkNaN=False, echo=self.echo)
        # TODO: fix bug
        elif isinstance(self.filebase, meca.Stress):
            self.dataInput = self.filebase.dataOutput
        else:
            raise TypeError('[ERROR] Unknown type of input data {}, should be <str> or <meca.Stress> object'.format(self.filebase))
        # Check where to count
        if self.gages is None: # count cycles on every spot over each tower gage
            print("|- [ALERT] Every stress history will be used to count Rainflow",
                  "cycles. If you don't mean it, try to choose serval tower gages in",
                  "order to reduce calculation time")
            allSpots = self.dataInput.getkeys()
            try:
                allSpots.remove('Time') # remove "Time" column
            except:
                pass
            self.spots = allSpots
        elif isinstance(self.gages[0], int): # count cycles over given tower gages
            available = self.dataInput.getkeys()
            try:
                available.remove('Time') # remove "Time" column
            except:
                pass
            for name in available:
                if int(name[4]) in self.gages:
                    self.spots.append(name)
                else:
                    print("|- [ALERT] There is no tower gage TwHt{} in input file".format(name[4]))
        else:
            raise Exception('[ERROR] Wrong list of tower gages {}, shoud be a list of integer numbers or None'.format(self.gages))

    def count(self):
        ''' Rainflow counting spot by spot
        '''
        for spot in self.spots:
            self.rainflowData[spot] = {'Cycle':collections.deque(),
                                       'Range':collections.deque(),
                                       'Mean':collections.deque()}
            #! HB: old rainflow syntax
            for valley, peak, cycle in rainflow.extract_cycles(
                self.dataInput.get(spot)['Records']):
                rangeValue = peak - valley
                meanValue = (peak+valley)/2
                self.rainflowData[spot]['Cycle'].append(cycle)
                self.rainflowData[spot]['Range'].append(rangeValue)
                self.rainflowData[spot]['Mean'].append(meanValue)
            #! HB: adapt to rainflow v3.0.0
            # for rangeValue, meanValue, cycle, _, __ in rainflow.extract_cycles(
            #         self.dataInput.get(spot)['Records']):
            #     self.rainflowData[spot]['Range'].append(rangeValue)
            #     self.rainflowData[spot]['Mean'].append(meanValue)
            #     self.rainflowData[spot]['Cycle'].append(cycle)

    def show(self):
        ''' Showing results on screen
        '''
        for spot in self.spots:
            data = self.rainflowData[spot]
            length = len(data['Cycle'])
            print('========== '+spot+' ==========')
            print('Num. of Cycles','Stress Range (MPa)','Stess Mean (MPa)')
            for i in range(length):
                print(data['Cycle'][i], data['Range'][i], data['Mean'][i])
            print('\n')

class Fatigue(object):
    ''' Calculate cumulative damage
        *ATTRIBUTES*
    '''
    def __init__(self, filebase, gages, lifetime, echo):
        self.filebase = filebase
        self.gages = gages
        self.lifetime = lifetime # Wind tower's designed lifetime per 10min
        self.echo = echo
        # Calculate cumulative fatigue damage
        try:
            self.run()
        except Exception as e:
            raise e

    def run(self):
        # initiate rainflow counting
        self.RFdata = Count(filebase=self.filebase, gages=self.gages, echo=self.echo)
        # initiate S-N curve
        self.curve = DNVGL('B1', Goodman=(True, 0.0))
        # some other attributes
        self.spots = self.RFdata.rainflowData.keys()
        self.damage = dict.fromkeys(self.spots)

    def _assess_damage(self, spot):
        ''' Assess cumulative damage on 1 single spot
        '''
        self.damage[spot] = {'n':collections.deque(), 'N':collections.deque(),
                             'D':collections.deque(), 'Dcumulate':0.0}
        self.damage[spot]['n'] = self.RFdata.rainflowData[spot]['Cycle']
        ranges = self.RFdata.rainflowData[spot]['Range']
        means = self.RFdata.rainflowData[spot]['Mean']
        # Calculate damage on every Rainflow cycle
        for i in range(len(ranges)):
            n = self.damage[spot]['n'][i]
            curve = self.curve.change_Goodman(means[i])
            N = curve.sn(ranges[i]) # find limit cycle from S-N curve
            self.damage[spot]['N'].append(N)
            D = n/N
            self.damage[spot]['D'].append(D)
        # Calculate cumulative damage on current spot ------------------------------------
        self.damage[spot]['Dcumulate'] = sum(self.damage[spot]['D'])
        # Calculate cumulative damage during wind turbine's designed lifetime ------------
        # self.damage[spot]['Dlife'] = self.damage[spot]['Dcumulate'] * self.lifetime
        # if self.echo:
        #     print('{}\t{}\t{}'.format(spot, self.damage[spot]['Dcumulate'],
        #           self.damage[spot]['Dlife']))

    def assess_spots(self):
        ''' Assess cumulative damage over all spots
        '''
        if self.echo:
            print("Spotname\tDamage during simulated time\tDamege during lifetime ( =",
                  "Damage during simulated time * lifetime)")
        list(map(self._assess_damage, self.spots))
        #! map() in Python 3 is LAZY. It won't get called until you ask for the value of
        #! that item in the mapped result, whether by using next() or some other way

    def save(self, filename=None):
        if filename is None: filename = self.filebase + ".dam"
        outputData = {}
        for key in self.damage.keys():
            outputData[key] = {'Dcumulate':self.damage[key]['Dcumulate'],
                               # 'Dlife':self.damage[key]['Dlife'],
                              }
        encode = json.dumps(outputData, indent=4)
        with open(filename, 'w') as f:
            f.write(encode)



#!------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!------------------------------------------------------------------------------
def get_fatigue(filebase, gages=None, lifetime=20*365*24*6, echo=False):
    temp = Fatigue(filebase=filebase, gages=gages, lifetime=lifetime, echo=echo)
    temp.assess_spots()
    temp.save()
    return filebase

def get_fatigue_multiprocess(list_filebase, gages=None, lifetime=20*365*24*6, echo=False):
    print('Fatigue Life Assessment v0.5 (November 7 2018)')
    print('========== Multiprocessing Mode ==========')
    print("[INFO] The evaluation of fatigue life is based on local stress. The current procedure will read Stress output file (.str) as input. This procedure has less performance than a direct evaluation from FAST output file (.out).\n If you don't want to save stress on spots to disk (.str), you can use  get_stress_fatigue_multiprocess instead. The latter runs more quickly and saves only the cumulative damage file (.dam) to disk")
    time.sleep(10)
    # prepare a callback function
    length = len(list_filebase)
    completed = []
    def printer(filebase):
        pos = list_filebase.index(filebase) + 1
        completed.append(filebase)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] Cumulative damage of {} is saved to disk at {}:{}. {} tasks'
              ' waiting to be completed ...'.format(pos, length, filebase, hour, minute,
              rest))
    # begin multiprocessing
    pool = multiprocessing.Pool()
    [pool.apply_async(get_fatigue, args=(filebase, gages, lifetime, echo),
     callback=printer, error_callback=utils.handle_error) for filebase in list_filebase]
    pool.close()
    pool.join()

def get_stress_fatigue(filebase, datarow, gages, thetaStep=30, lifetime=20*365*24*6,
                       echo=False):
    stress = meca.get_stress(filebase, datarow, gages, thetaStep, False, echo)
    temp = Fatigue(stress, gages, lifetime, echo)
    temp.assess_spots()
    temp.save(filebase+'.dam')
    return filebase

def get_stress_fatigue_multiprocess(list_filebase, datarow, gages, thetaStep=30, lifetime=20*365*24*6, echo=False):
    print('Fatigue Life Assessment v0.5 (November 7 2018)')
    print('========== Multiprocessing Mode ==========')
    # prepare a callback function
    length = len(list_filebase)
    completed = []
    def printer(filebase):
        pos = list_filebase.index(filebase) + 1
        completed.append(filebase)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] Cumulative damage of {} is saved to disk at {}:{}. {} tasks'
              ' waiting to be completed ...'.format(pos, length, filebase, hour, minute,
              rest))
    # begin multiprocessing
    pool = multiprocessing.Pool()
    [pool.apply_async(get_stress_fatigue, args=(filebase, datarow, gages, thetaStep, lifetime, echo),
     callback=printer, error_callback=utils.handle_error) for filebase in list_filebase]
    pool.close()
    pool.join()


#!------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!------------------------------------------------------------------------------
@utils.timer
def main():
    with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Output/DLC1.1/'):
        test = 3
        # Testing DNGVL class
        if test == 1:
            curve = DNVGL('B1', Goodman=(True, 20.0))
            # print(curve.sn(curve.ns(1e7)))
            # curve.plotSN()
            # curve = DNVGL('C2')
            # curve.plotSN()
            # print('|- OK')
            curve.change_Goodman(0.0)

        # Testing Count class
        if test == 2:
            # myCount1 = Count('DLC1.2_NTM_25mps', echo=1)
            myCount2 = Count('NTM_3.5mps_-1890945502', gages=[1, 9])
            # myCount3 = Count('DLC1.2_NTM_25mps')
            # test = meca.get_stress(
            #     'NTM_3.5mps_-1890945502', 6009, [1, 9],
            #     thetaStep=180, saveToDisk=True, echo=True)
            # myCount4 = Count(test, gages=[1,9])

        # Tesint Fatigue class
        if test == 3:
            # analysis = Fatigue('DLC1.2_NTM_25mps', gages=[1,9], lifetime=20*365*24*6, echo=0)
            # analysis.assess_spots()
            # analysis._assess_damage('TwHt1@0')
            # analysis.save()
            get_fatigue('NTM_3.5mps_-1890945502', [1, 9])
            # get_stress_fatigue('DLC1.2_NTM_25mps', 6009, [1,9], 30, echo=False)
            # get_stress_fatigue('DLC1.2_NTM_25mps', 6009, [1,2,3,4,5,6,7,8,9], 30)
        


#!------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
