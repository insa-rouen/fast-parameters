#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DLC
#
# Authors: Hao BAI (hao.bai@insa-rouen.fr)
# Version: 0.0
# Date: 28/10/2018
#
# Comments:
#     - 0.0: Create a general class for preparing FAST input scripts
#     - 0.1: Add DLC11 class designed for DLC1.1
#     - 0.2: Create a supervising function for multiprocess
#     - 0.3: Remove input parameter 'moveSource' in <class DLC>
#     - 0.4ï¼šAdd DLC23 class; Add TRD class
#     - 0.5: Add DLC01 class
# Description:
#     Prepare a general class for DLC input scripts
#     Customize each DLC input script
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!------------------------------------------------------------------------------
#!                                   MODULES
#!------------------------------------------------------------------------------
#*         ==================== Modules Personnels ====================
from tools import utils
try:
    import sys, IPython # to colorize traceback errors in terminal
    sys.excepthook = IPython.core.ultratb.ColorTB()
except:
    pass
#*           ==================== Modules Communs ====================
import re
import os
import json
import time
import platform
import fileinput # iterate over lines from multiple input files
import shutil # high-level file operations
import subprocess # call a bash command e.g. 'ls'
import multiprocessing # enable multiprocessing
from pathlib import Path


#!------------------------------------------------------------------------------
#!                                   GLOBAL VARIABLE
#!------------------------------------------------------------------------------
CORES = os.cpu_count()



#!------------------------------------------------------------------------------
#!                                   CLASS DEFINITION
#!------------------------------------------------------------------------------
class DLC(object):
    """ A basic class that provides methods to customize FAST input scripts
        ATTRIBUTES
    """
    def __init__(self, case, outputFolder, echo):
        self.case = case
        self.echo = echo
        # Get OS platform name
        self._system = {'Linux':'FAST_glin64', 'Darwin':'FAST_gdar64'}
        self._fastName = self._system.get(platform.system())
        # some fixed path
        self._workPath = Path('~/Eolien/Parameters/Python/{}'.format(self.case)).expanduser()
        self._outputPath=Path('~/Eolien/Parameters/Python/{0}/Output/{0}'.format
                            (self.case), '{}'.format(outputFolder)).expanduser()
        self._windPath = Path('~/Eolien/Parameters/Python/{0}/Wind/{0}'.format(
                              self.case)).expanduser()
        self._wtPath = Path('~/Eolien/Parameters/Python/{}/WT'.format(self.case)
                           ).expanduser()
        self._logPath=Path('~/Eolien/Parameters/Python/{}/log'.format(self.case)
                          ).expanduser()
        # Check working directory
        self.__check_directory()
    
    @property
    def workPath(self):
        return self._workPath
    
    @workPath.setter
    def workPath(self, value):
        self._workPath = Path(value).expanduser()
        self._workPath.mkdir(exist_ok=True) # create folder if non-existant

    @property
    def outputPath(self):
        return self._outputPath
    
    @outputPath.setter
    def outputPath(self, value):
        self._outputPath = Path(value).expanduser()
        self._outputPath.mkdir(exist_ok=True) # create folder if non-existant

    @property
    def windPath(self):
        return self._windPath
    
    @windPath.setter
    def windPath(self, value):
        self._windPath = Path(value).expanduser()
        if not self._windPath.exists(): # create link if non-existant
            target = Path('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'
                         ).expanduser()
            self._windPath.symlink_to(target, target_is_directory=True)

    @property
    def wtPath(self):
        return self._wtPath
    
    @wtPath.setter
    def wtPath(self, value):
         self._wtPath = Path(value).expanduser()
         if not self._wtPath.exists():
            target = Path('~/Eolien/Parameters/NREL_5MW_Onshore/WT'
                         ).expanduser()
            self._wtPath.symlink_to(target, target_is_directory=True)
    
    @property
    def logPath(self):
        return self._logPath
    
    @logPath.setter
    def logPath(self, value):
         self._logPath = Path(value).expanduser()

    @property
    def __id(self):
        if hasattr(self, "seed"):
            return self.seed
        elif hasattr(self, "gridloss"):
            return self.gridloss
        elif hasattr(self, "speed"):
            return self.speed
        else:
            raise ValueError("|- [ERROR] Can't get the object attribute "
                             ".__id which is indispensable for saving log file")

    def __check_directory(self):
        # Check work directory
        self._workPath.mkdir(exist_ok=True) # create if non-existant
        # Check output folder
        link = Path('~/Eolien/Parameters/Python/{}/Output'.format(self.case)
                   ).expanduser()
        if not link.exists():
            target = Path('~/Eolien/Parameters/NREL_5MW_Onshore/Output'
                         ).expanduser()
            link.symlink_to(target, target_is_directory=True)
        self._outputPath.mkdir(exist_ok=True) # create if non-existant
        # Check wind profile folder
        link = Path('~/Eolien/Parameters/Python/{}/Wind'.format(self.case)
                   ).expanduser()
        if not link.exists():
            target = Path('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'
                         ).expanduser()
            link.symlink_to(target, target_is_directory=True)
        # Check WT folder
        link = Path('~/Eolien/Parameters/Python/{}/WT'.format(self.case)
                   ).expanduser()
        if not link.exists():
            target = Path('~/Eolien/Parameters/NREL_5MW_Onshore/WT'
                         ).expanduser()
            link.symlink_to(target, target_is_directory=True)

    def _change_number(self, string, keyword, value):
        position = string.find(keyword)
        substring = string[:position]
        # replace float number (e.g. 12.34; 12.; .34)
        new_substring = re.sub('[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)',str(value), 
                               substring)
        newline = new_substring + string[position:]
        return newline

    def _fast(self, silence):
        """ Call FAST program
        """
        #with utils.cd('~/Eolien/FAST'):
        command = '{0} {1}'.format(self._fastName, str(self.fastFile))
        try:
            if silence:
                output = subprocess.check_output([command], shell=True)
            else:
                output = subprocess.check_call([command], shell=True)
                    # Note:
                    # When shell=False, args[:] is a command line to execute
                    # When shell=True, args[0] is a command line to execute and 
                    # args[1:] is arguments to sh
        except subprocess.CalledProcessError as error:
            wrong = True
                # print('error: \n', error)
            errorMessage = error.output # works only when silence = TRUE
        except Exception as e:
            wrong = True
            raise e
        else:
            wrong = False
        # If an error occurs during execution, write output message to file
        if wrong is not False:
            self.logPath.mkdir(exist_ok=True) # create new folder if non-exist
            filename = self.logPath.joinpath('{}.FAST.bug'.format(self.__id[2]))
            filename.write_bytes(errorMessage)
            utils.add_failed_seeds('FAST', self.__id)
            raise Exception("|- [ERROR] FAST has an error for simulation {}, "
                            "please see report in {}".format(self.__id,
                            filename))


#*          ==================== Common DLCs ====================
class DLC_turbulence(DLC):
    """ DLCs with turbulence model: NTM or ETM
        *ATTRIBUTES*
            seed: seed ID [int]
    """
    def __init__(self, seed, case, outputFolder, echo):
        super(DLC_turbulence, self).__init__(case, outputFolder, echo)
        self.seed =  seed
        self.fastFile = '{}_{}_{}mps.fst'.format(self.case, self.seed[0],
                                                 self.seed[1])
        self.inflowFile = '{}_{}_{}mps.IW.dat'.format(self.case, self.seed[0], 
                                                      self.seed[1])

    def _change_wind_profil(self):
        # InflowWind input script ----------------------------------------------
        filename = self.workPath.joinpath(self.inflowFile)
        data = filename.read_text()
        data = self._change_string(data, 'Filename')

        filename = self.workPath.joinpath('{}_{}_{}mps_{}.IW.dat'.format(
                           self.case, self.seed[0], self.seed[1], self.seed[2]))
        filename.write_text(data)
        self.inflowFile = filename # update Inflow .dat file

        # FAST input script ----------------------------------------------------
        filename = self.workPath.joinpath(self.fastFile)
        data = filename.read_text()
        data = self._change_string(data, 'InflowFile')
        
        filename = self.workPath.joinpath('{}_{}_{}mps_{}.fst'.format(self.case,
                                      self.seed[0], self.seed[1], self.seed[2]))
        filename.write_text(data)
        self.fastFile = filename # update .fst file

    def _change_string(self, text, keyword):
        if keyword == 'Filename':
            old="{}/{}_{}mps.bts".format(self.case, self.seed[0], self.seed[1])
            new="{}/{}_{}mps_{}.bts".format(self.case,self.seed[0],self.seed[1],
                                            self.seed[2])
            text = re.sub(old, new ,text)

        if keyword == 'InflowFile':
            old="{}_{}_{}mps.IW.dat".format(self.case,self.seed[0],self.seed[1])
            new="{}_{}_{}mps_{}.IW.dat".format(self.case,self.seed[0],
                                               self.seed[1], self.seed[2])
            text = re.sub(old, new ,text)
        return text

    def _move(self):
        """ Move and rename files
        """
        # FAST output file (.out) to output folder -----------------------------
        source = self.workPath.joinpath('{}_{}_{}mps_{}.out'.format(self.case,
                                       self.seed[0], self.seed[1],self.seed[2]))
        destination = self.outputPath.joinpath(
                                          '{}_{}mps_{}.out'.format(self.seed[0],
                                          self.seed[1], self.seed[2]))
        source.replace(destination)


#*          ==================== Individual DLCs ====================
class DLC01(DLC):
    """ DLC0.1 Uniform wind
    """
    def __init__(self, speed):
        super().__init__("DLC0.1", "", False)
        self.speed = speed
        self.fastFile = "{}.fst".format(self.case)
        self.inflowFile = "{}.IW.dat".format(self.case)

    def run(self, silence=False):
        self._change_wind_speed()
        super()._fast(silence)
        self._move()

    def _change_wind_speed(self):
        root = Path("~/Eolien/Parameters/NREL_5MW_Onshore").expanduser()
        # InflowWind input script ----------------------------------------------
        filename = root.joinpath(self.inflowFile)
        data = filename.read_text()
        data = self._change_string(data, 'Filename')
        filename = self.workPath.joinpath('{}_CST_{}mps.IW.dat'.format(
                                                         self.case, self.speed))
        filename.write_text(data)
        self.inflowFile = filename # update Inflow .dat file

        # FAST input script ----------------------------------------------------
        filename = root.joinpath(self.fastFile)
        data = filename.read_text()
        data = self._change_string(data, 'InflowFile')
        filename = self.workPath.joinpath('{}_CST_{}mps.fst'.format(self.case,
                                                                    self.speed))
        filename.write_text(data)
        self.fastFile = filename # update .fst file

    def _change_string(self, text, keyword):
        if keyword == 'Filename':
            old = "{}/CST_11.4mps.wnd".format(self.case)
            new = "{}/CST_{}mps.wnd".format(self.case, self.speed)
            text = re.sub(old, new ,text)

        if keyword == 'InflowFile':
            old = "{}.IW.dat".format(self.case)
            new = "{}_CST_{}mps.IW.dat".format(self.case, self.speed)
            text = re.sub(old, new ,text)
        return text

    def _move(self):
        """ Move and rename files
        """
        # FAST output file (.out) to output folder -----------------------------
        source = self.workPath.joinpath("{}_CST_{}mps.out".format(self.case,
                                        self.speed))
        destination = self.outputPath.joinpath("CST_{}.out".format(self.speed))
        source.replace(destination)


class DLC11(DLC_turbulence):
    """ DLC1.1 NTM
        Mean wind speed: Vcut-in <= Vhub <= Vcut-out
        ATTRIBUTES
            seed: seed ID [int]
    """
    def __init__(self, seed, case='DLC1.1', outputFolder='', echo=False):
        super(DLC11, self).__init__(seed, case, outputFolder, echo)
        
    def run(self, silence=False):
        self._change_wind_profil()
        super()._fast(silence)
        self._move()


class DLC23(DLC):
    """ DLC2.3 EOG
        Mean wind speed: Vcut-in, Vrated-2.0, Vrated, Vrated+2.0, Vcut-out
        ATTRIBUTES
            time: gridloss time [float]
    """
    def __init__(self, gridloss, case='DLC2.3', outputFolder='', echo=False):
        super(DLC23, self).__init__(case, outputFolder, echo)
        self.gridloss = gridloss
        self.fastFile = '{}_{}_{}.fst'.format(self.case, self.gridloss[0],
                                              self.gridloss[1])
        self.servoFile = 'ServoDyn_DLC2.3.dat'
        
    def run(self, silence=False):
        self._change_gridloss()
        super()._fast(silence)
        self._move()

    def _change_gridloss(self):
        # ServoDyn input script ------------------------------------------------
        filename = self.wtPath.joinpath(self.servoFile)
        with open(filename) as f:
            data = f.readlines()
            for index, line in enumerate(data):
                if "TimGenOf" in line: # Rotor shutdown time
                    data[index] = self._change_number(line,"TimGenOf",
                                                        float(self.gridloss[2]))
                elif "TPitManS" in line: # Pitch-to-Feather start time
                    data[index] = self._change_number(line, "TPitManS",
                                                    float(self.gridloss[2])+0.2)
                elif "THSSBrDp" in line: # High-Speed-Shaft start time
                    data[index] = self._change_number(line,"THSSBrDp",
                                              float(self.gridloss[2])+0.2+11.25)
        filename = self.wtPath.joinpath('ServoDyn_DLC2.3_{}.dat'
                                        .format(self.gridloss[2]))
        filename.open('w').writelines(data)
        self.servoFile = filename # update ServoDyn .dat file

        # FAST input script ----------------------------------------------------
        filename = self.workPath.joinpath(self.fastFile)
        data = filename.read_text()
        data = self._change_string(data, 'ServoFile')
        
        filename = self.workPath.joinpath('{}_{}_{}_{}.fst'.format(self.case,
                          self.gridloss[0], self.gridloss[1], self.gridloss[2]))
        filename.write_text(data)
        self.fastFile = filename # update .fst file

    def _change_string(self, text, keyword):
        if keyword == 'ServoFile':
            old = "WT/ServoDyn_{}.dat".format(self.case)
            new = "WT/ServoDyn_{}_{}.dat".format(self.case, self.gridloss[2])
        return re.sub(old, new, text)

    def _move(self):
        """ Move and rename files
        """
        # FAST output file (.out) to output folder -----------------------------
        source = self.workPath.joinpath('{}_{}_{}_{}.out'.format(self.case,
                                        self.gridloss[0], self.gridloss[1],
                                        self.gridloss[2]))
        destination = self.outputPath.joinpath(
                                         '{}_{}_{}.out'.format(self.gridloss[0],
                                         self.gridloss[1], self.gridloss[2]))
        source.replace(destination)


class TRD(DLC23):
    """ TRD
        ATTRIBUTES
            time: gridloss time [float]
    """
    def __init__(self, mode1, gridloss, case, outputFolder='',
                 echo=False):
        super(TRD, self).__init__(gridloss, case, outputFolder, echo)
        self.mode1 = mode1
        self.__id = "".join(map(str, self.mode1))
        self.servoTRDFile = "ServoDyn_TRD.dat"
        self.outputFilename = ""

    def run(self, silence=False):
        self._change_TRD()
        super()._fast(silence)
        self._move()       

    def _change_TRD(self):
        # ServoDyn_TRD.dat -----------------------------------------------------
        filename = self.wtPath.joinpath(self.servoTRDFile)
        with open(filename, 'r') as f:
            data = f.readlines()
            for index, line in enumerate(data):
                if 'TRD_K(1)' in line:
                    data[index] = self._change_number(line, 'TRD_K(1)',
                                                    self.mode1[0])
                if 'TRD_K(2)' in line:
                    data[index] = self._change_number(line, 'TRD_K(2)',
                                                    self.mode1[1])
                if 'TRD_L(1)' in line:
                    data[index] = self._change_number(line, 'TRD_L(1)',
                                                    self.mode1[2])
                if 'TRD_L(2)' in line:
                    data[index] = self._change_number(line, 'TRD_L(2)',
                                                    self.mode1[3])
        filename = self.wtPath.joinpath('ServoDyn_TRD_{}.dat'
                                        .format(self.__id))
        filename.open('w').writelines(data)
        self.servoTRDFile = filename # update ServoDyn_TRD .dat file


        # ServoDyn input script ------------------------------------------------
        filename = self.wtPath.joinpath(self.servoFile)
        with open(filename) as f:
            data = f.readlines()
            for index, line in enumerate(data):
                if len(self.gridloss) == 3:
                    if "TimGenOf" in line: # Rotor shutdown time
                        data[index] = self._change_number(line, "TimGenOf",
                                                        float(self.gridloss[2]))
                    elif "TPitManS" in line: # Pitch-to-Feather start time
                        data[index] = self._change_number(line, "TPitManS",
                                                    float(self.gridloss[2])+0.2)
                    elif "THSSBrDp" in line: # High-Speed-Shaft start time
                        data[index] = self._change_number(line, "THSSBrDp",
                                              float(self.gridloss[2])+0.2+11.25)
                if 'NTRDfile' in line:
                    data[index] = self._change_string(line, "NTRDfile",
                                                      self.servoTRDFile.name)
        filename = self.wtPath.joinpath('ServoDyn_DLC2.3_{}.dat'
                                        .format(self.__id))
        filename.open('w').writelines(data)
        self.servoFile = filename # update ServoDyn .dat file


        # FAST input script ----------------------------------------------------
        filename = self.workPath.joinpath(self.fastFile)
        data = filename.read_text()
        data = self._change_string(data, 'ServoFile')
        
        filename = self.workPath.joinpath('{}_{}_{}_{}.fst'.format(self.case,
                                 self.gridloss[0], self.gridloss[1], self.__id))
        filename.write_text(data)
        self.fastFile = filename # update .fst file

    def _change_string(self, text, keyword, new=""):
        if keyword == 'ServoFile':
            old = "WT/ServoDyn_{}.dat".format(self.case)
            new = "WT/{}".format(self.servoFile.name)

        if keyword == 'NTRDfile':
            old = "ServoDyn_TRD.dat"
        return re.sub(old, new, text)

    def _move(self):
        """ Move and rename files
        """
        # FAST output file (.out) to output folder -----------------------------
        source = self.workPath.joinpath('{}_{}_{}_{}.out'.format(self.case,
                                 self.gridloss[0], self.gridloss[1], self.__id))
        self.outputFilename = '{}_{}_{}.out'.format(self.gridloss[0],
                                                    self.gridloss[1], self.__id)
        destination = self.outputPath.joinpath(self.outputFilename)
        source.replace(destination)


#!------------------------------------------------------------------------------
#!                                 FUNCTION DEFINITION
#!------------------------------------------------------------------------------
def get_DLC01(speed, silence=False):
    temp = DLC01(speed=speed)
    temp.run(silence)
    return speed

def get_DLC01_multiprocess(list_speed, silence=False, echo=False):
    print('DLC v0.5 (November 28 2018)')
    print('========== Multiprocessing Mode ==========')
    # prepare a callback function
    length = len(list_speed)
    completed = []
    def printer(speed):
        pos = list_speed.index(speed) + 1
        completed.append(speed)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] Simulation for CST wind at {} m/s is terminated at '
              '{}:{}. {} tasks waiting to be completed ...'.format(pos, length,
              speed, hour, minute, rest))
    # begin multiprocessing
    pool = multiprocessing.Pool(CORES)
    [pool.apply_async(get_DLC01, args=(speed, silence), callback=printer,
     error_callback=utils.handle_error) for speed in list_speed]
    pool.close()
    pool.join()

def get_DLC11(seed, outputFolder='',  silence=False, echo=False):
    temp = DLC11(seed=seed, outputFolder=outputFolder, echo=echo)
    temp.run(silence=silence)
    return seed

def get_DLC11_multiprocess(list_seed, outputFolder='', silence=False,
                           echo=False):
    print('DLC v0.5 (November 28 2018)')
    print('========== Multiprocessing Mode ==========')
    # prepare a callback function
    length = len(list_seed)
    completed = []
    def printer(seed):
        pos = list_seed.index(seed) + 1
        completed.append(seed)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] Simulation for {} wind at {} m/s with seed ID {} is'
              ' terminated at {}:{}. {} tasks waiting to be completed ...'
              .format(pos,length, seed[0], seed[1], seed[2], hour,minute, rest))
    # begin multiprocessing
    pool = multiprocessing.Pool(CORES)
    [pool.apply_async(get_DLC11, args=(seed, outputFolder, silence, echo),
     callback=printer, error_callback=utils.handle_error) for seed in list_seed]
    pool.close()
    pool.join()

def get_DLC23(gridloss, outputFolder='', silence=False, echo=False):
    temp = DLC23(gridloss=gridloss, outputFolder=outputFolder, echo=echo)
    temp.run(silence=silence)
    return gridloss

def get_DLC23_multiprocess(list_gridloss, outputFolder='', silence=False,
                           echo=False):
    print('DLC v0.5 (November 28 2018)')
    print('========== Multiprocessing Mode ==========')
    # prepare a callback function
    length = len(list_gridloss)
    completed = []
    def printer(gridloss):
        pos = list_gridloss.index(gridloss) + 1
        completed.append(gridloss)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] Simulation for {} wind at {} with gridloss on {} s is'
              ' terminated at {}:{}. {} tasks waiting to be completed ...'
              .format(pos, length, gridloss[0], gridloss[1], gridloss[2], hour,
              minute, rest))
    # begin multiprocessing
    pool = multiprocessing.Pool(CORES)
    [pool.apply_async(get_DLC23, args=(gridloss, outputFolder, silence, echo),
     callback=printer, error_callback=utils.handle_error) for gridloss in list_gridloss]
    pool.close()
    pool.join()

def get_TRD(mode1, gridloss, case='DLC2.3', outputFolder='', silence=False,
            echo=False):
    temp = TRD(mode1=mode1,gridloss=gridloss,case=case,outputFolder=outputFolder, 
               echo=echo)
    # set path
    temp.workPath = '~/Eolien/Parameters/Python/TRD'
    temp.outputPath = '~/Eolien/Parameters/Python/TRD/Output/{}_TRD'.format(
                      temp.case)
    temp.outputPath = temp.outputPath.joinpath('{}'.format(outputFolder))
    temp.windPath = "~/Eolien/Parameters/Python/TRD/Wind"
    temp.wtPath = "~/Eolien/Parameters/Python/Optimization/WT"
    temp.logPath = '~/Eolien/Parameters/Python/TRD/log'.format(temp.case)
    # run calculation
    temp.run(silence)
    return mode1



#!------------------------------------------------------------------------------
#!                                    MAIN FUNCTION
#!------------------------------------------------------------------------------
@utils.timer
def main():
    # Load seeds
    with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'):
        with open('6seeds.json', 'r') as f:
            seeds = json.loads(f.read())

    liste = []
    [liste.append(s) for s in seeds if s[0] == "NTM"]
    seeds = liste[:1]

    # ----- Running on single processor
    # get_DLC11(seeds[0])
    # get_DLC11(['NTM','13','-1491944232'], silence=False)
    # get_DLC23(['EOG', 'R', '77.7'])
    get_TRD([290, 30, -90, -20], ['EOG', 'R', '77.7'], outputFolder='opti')

    # Test a case that will produce error during FAST calculation
    get_DLC11(['NTM','3','1480621087'], silence=1)

    # ----- Running on multi processor
    # get_DLC23_multiprocess([['EOG', 'R', '77.6'], ['EOG', 'R', '77.8']], silence=1)



#!------------------------------------------------------------------------------
#!                                     RUNNING TEST
#!------------------------------------------------------------------------------
if __name__ == '__main__':
        main()
