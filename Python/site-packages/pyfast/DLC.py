#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DLC
#
# Authors: Hao BAI (hao.bai@insa-rouen.fr)
# Version: 0.0
# Date: 28/10/2018
#
# Comments:
#     - 0.0: Create a general class for preparing FAST input scripts
#     - 0.1: Add DLC11 class designed for DLC1.1
#     - 0.2: Create a supervising function for multiprocess
#     - 0.3: Remove input parameter 'moveSource' in <class DLC>
# Description:
#     Prepare a general class for DLC input scripts
#     Customize each DLC input script
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!------------------------------------------------------------------------------
#!                                   MODULES
#!------------------------------------------------------------------------------
#*         ==================== Modules Personnels ====================
from tools import utils
import sys, IPython # to colorize traceback errors in terminal
sys.excepthook = IPython.core.ultratb.ColorTB()
#*           ==================== Modules Communs ====================
import re
import json
import time
import platform
import fileinput # iterate over lines from multiple input files
import shutil # high-level file operations
import subprocess # call a bash command e.g. 'ls'
import multiprocessing # enable multiprocessing
from pathlib import Path



#!------------------------------------------------------------------------------
#!                                   CLASS DEFINITION
#!------------------------------------------------------------------------------
class DLC(object):
    ''' A basic class that provides methods to customize FAST input scripts
        *ATTRIBUTES*
    '''
    def __init__(self, case, outputFolder, echo):
        self.case = case
        self.outputFolder = outputFolder
        self.echo = echo
        # Get OS platform name
        self._system = {'Linux':'FAST_glin64', 'Darwin':'FAST_gdar64'}
        self._fastName = self._system.get(platform.system())
        # some fixed path
        self.workPath = Path('~/Eolien/Parameters/Python/{}'.format(self.case))
        self.workPath = self.workPath.expanduser()
        self.outputPath=Path('~/Eolien/Parameters/Python/{0}/Output/{0}'.format
                             (self.case))
        self.outputPath = self.outputPath.expanduser()
        self.windPath = Path('~/Eolien/Parameters/Python/{0}/Wind/{0}'.format(self.case))
        self.windPath = self.windPath.expanduser()
        self.wtPath = Path('~/Eolien/Parameters/Python/{}/WT'.format(self.case))
        self.wtPath = self.wtPath.expanduser()
        self.logPath=Path('~/Eolien/Parameters/Python/{}/log'.format(self.case))
        self.logPath = self.logPath.expanduser()
        
        # Check working directory
        self.__check_directory()
    
    @property
    def __id(self):
        if hasattr(self, "seed"):
            return self.seed
        elif hasattr(self, "gridloss"):
            return self.gridloss
        else:
            raise ValueError("|- [ERROR] Can't get the object attribute "
                             ".__id which is indispensable for saving log file")

    def __check_directory(self):
        # Check output folder
        link = Path('~/Eolien/Parameters/Python/{}/Output'.format(self.case)
                   ).expanduser()
        if not link.exists():
            target = Path('~/Eolien/Parameters/NREL_5MW_Onshore/Output'
                         ).expanduser()
            link.symlink_to(target, target_is_directory=True)
        # Check wind profile folder
        link = Path('~/Eolien/Parameters/Python/{}/Wind'.format(self.case)
                   ).expanduser()
        if not link.exists():
            target = Path('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'
                         ).expanduser()
            link.symlink_to(target, target_is_directory=True)
        # Check WT folder
        link = Path('~/Eolien/Parameters/Python/{}/WT'.format(self.case)
                   ).expanduser()
        if not link.exists():
            target = Path('~/Eolien/Parameters/NREL_5MW_Onshore/WT'
                         ).expanduser()
            link.symlink_to(target, target_is_directory=True)

    def _change_number(self, string, keyword, value):
        position = string.find(keyword)
        substring = string[:position]
        # replace float number (e.g. 12.34; 12.; .34)
        new_substring = re.sub('[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)',str(value), 
                               substring)
        newline = new_substring + string[position:]
        return newline

    def _fast(self, silence):
        ''' Call FAST program
        '''
        with utils.cd('~/Eolien/FAST'):
            command = './{0} {1}'.format(self._fastName, str(self.fastFile))
            try:
                if silence:
                    output = subprocess.check_output([command], shell=True)
                else:
                    output = subprocess.check_call([command], shell=True)
                    # Note:
                    # When shell=False, args[:] is a command line to execute
                    # When shell=True, args[0] is a command line to execute and 
                    # args[1:] is arguments to sh
            except subprocess.CalledProcessError as error:
                wrong = True
                # print('error: \n', error)
                errorMessage = error.output # works only when silence = TRUE
            except Exception as e:
                wrong = True
                raise e
            else:
                wrong = False
        # If an error occurs during execution, write output message to file
        if wrong is not False:
            self.logPath.mkdir(exist_ok=True) # create new folder if non-exist
            filename = self.logPath.joinpath('{}.FAST.bug'.format(self.__id[2]))
            filename.write_bytes(errorMessage)
            utils.add_failed_seeds('FAST', self.__id)
            raise Exception("|- [ERROR] FAST has an error for simulation {}, "
                            "please see report in {}".format(self.__id,
                            filename))


#*          ==================== Common DLCs ====================
class DLC_turbulence(DLC):
    ''' DLCs with turbulence model: NTM or ETM
        *ATTRIBUTES*
            seed: seed ID [int]
    '''
    def __init__(self, seed, case, outputFolder, echo):
        super(DLC_turbulence, self).__init__(case, outputFolder, echo)
        self.seed =  seed
        self.fastFile = '{}_{}_{}mps.fst'.format(self.case, self.seed[0],
                                                 self.seed[1])
        self.inflowFile = '{}_{}_{}mps.IW.dat'.format(self.case, self.seed[0], 
                                                      self.seed[1])

    def _change_wind_profil(self):
        # InflowWind input script ----------------------------------------------
        filename = self.workPath.joinpath(self.inflowFile)
        data = filename.read_text()
        data = self._change_string(data, 'Filename')

        filename = self.workPath.joinpath('{}_{}_{}mps_{}.IW.dat'.format(
                           self.case, self.seed[0], self.seed[1], self.seed[2]))
        filename.write_text(data)
        self.inflowFile = filename # update Inflow .dat file

        # FAST input script ----------------------------------------------------
        filename = self.workPath.joinpath(self.fastFile)
        data = filename.read_text()
        data = self._change_string(data, 'InflowFile')
        
        filename = self.workPath.joinpath('{}_{}_{}mps_{}.fst'.format(self.case,
                                      self.seed[0], self.seed[1], self.seed[2]))
        filename.write_text(data)
        self.fastFile = filename # update .fst file

    def _change_string(self, text, keyword):
        if keyword == 'Filename':
            old="{}/{}_{}mps.bts".format(self.case, self.seed[0], self.seed[1])
            new="{}/{}_{}mps_{}.bts".format(self.case,self.seed[0],self.seed[1],
                                            self.seed[2])
            text = re.sub(old, new ,text)

        if keyword == 'InflowFile':
            old="{}_{}_{}mps.IW.dat".format(self.case,self.seed[0],self.seed[1])
            new="{}_{}_{}mps_{}.IW.dat".format(self.case,self.seed[0],
                                               self.seed[1], self.seed[2])
            text = re.sub(old, new ,text)
        return text

    def _move(self):
        ''' Move and rename files
        '''
        # FAST output file (.out) to output folder -----------------------------
        source = self.workPath.joinpath('{}'.format(self.outputFolder),
                                       '{}_{}_{}mps_{}.out'.format(self.case,
                                       self.seed[0], self.seed[1],self.seed[2]))
        destination = self.outputPath.joinpath('{}'.format(self.outputFolder),
                                          '{}_{}mps_{}.out'.format(self.seed[0],
                                          self.seed[1], self.seed[2]))
        source.replace(destination)


#*          ==================== Individual DLCs ====================
class DLC11(DLC_turbulence):
    ''' DLC1.1 NTM
        Mean wind speed: Vcut-in <= Vhub <= Vcut-out
        *ATTRIBUTES*
            seed: seed ID [int]
    '''
    def __init__(self, seed, case='DLC1.1', outputFolder='', echo=False):
        super(DLC11, self).__init__(seed, case, outputFolder, echo)
        
    def run(self, silence=False):
        self._change_wind_profil()
        super()._fast(silence)
        self._move()


class DLC23(DLC):
    ''' DLC2.3 EOG
        Mean wind speed: Vcut-in, Vrated-2.0, Vrated, Vrated+2.0, Vcut-out
        *ATTRIBUTES*
            time: gridloss time [float]
    '''
    def __init__(self, gridloss, case='DLC2.3', outputFolder='', echo=False):
        super(DLC23, self).__init__(case, outputFolder, echo)
        self.gridloss = gridloss
        self.fastFile = '{}_{}_{}.fst'.format(self.case, self.gridloss[0],
                                              self.gridloss[1])
        self.servoFile = 'ServoDyn_DLC2.3.dat'
        
    def run(self, silence=False):
        self._change_gridloss()
        super()._fast(silence)
        self._move()

    def _change_gridloss(self):
        # ServoDyn input script ------------------------------------------------
        filename = self.wtPath.joinpath(self.servoFile)
        with open(filename) as f:
            data = f.readlines()
            for index, line in enumerate(data):
                if "TimGenOf" in line: # Rotor shutdown time
                    data[index] = self._change_number(line,"TimGenOf",
                                                      float(self.gridloss[2]))
                elif "TPitManS" in line: # Pitch-to-Feather start time
                    data[index] = self._change_number(line, "TPitManS",
                                                      float(self.gridloss[2])+0.2)
                elif "THSSBrDp" in line: # High-Speed-Shaft start time
                    data[index] = self._change_number(line,"THSSBrDp",
                                                      float(self.gridloss[2])+0.2+11.25)
        filename = self.wtPath.joinpath('ServoDyn_DLC2.3_{}.dat'
                                        .format(self.gridloss[2]))
        filename.open('w').writelines(data)
        self.servoFile = filename # update ServoDyn .dat file

        # FAST input script ----------------------------------------------------
        filename = self.workPath.joinpath(self.fastFile)
        data = filename.read_text()
        data = self._change_string(data, 'ServoFile')
        
        filename = self.workPath.joinpath('{}_{}_{}_{}.fst'.format(self.case,
                          self.gridloss[0], self.gridloss[1], self.gridloss[2]))
        filename.write_text(data)
        self.fastFile = filename # update .fst file

    def _change_string(self, text, keyword):
        if keyword == 'ServoFile':
            old = "WT/ServoDyn_{}.dat".format(self.case)
            new = "WT/ServoDyn_{}_{}.dat".format(self.case, self.gridloss[2])
            text = re.sub(old, new ,text)
        return text

    def _move(self):
        ''' Move and rename files
        '''
        # FAST output file (.out) to output folder -----------------------------
        source = self.workPath.joinpath('{}'.format(self.outputFolder),
                                        '{}_{}_{}_{}.out'.format(self.case,
                                        self.gridloss[0], self.gridloss[1],
                                        self.gridloss[2]))
        destination = self.outputPath.joinpath('{}'.format(self.outputFolder),
                                        '{}_{}_{}.out'.format(self.gridloss[0],
                                        self.gridloss[1], self.gridloss[2]))
        source.replace(destination)



#!------------------------------------------------------------------------------
#!                                 FUNCTION DEFINITION
#!------------------------------------------------------------------------------
def get_DLC11(seed, outputFolder='',  silence=False, echo=False):
    temp = DLC11(seed=seed, outputFolder=outputFolder, echo=echo)
    temp.run(silence=silence)
    return seed

def get_DLC11_multiprocess(list_seed, outputFolder='', silence=False,
                           echo=False):
    print('DLC v0.3 (November 20 2018)')
    print('========== Multiprocessing Mode ==========')
    # prepare a callback function
    length = len(list_seed)
    completed = []
    def printer(seed):
        pos = list_seed.index(seed) + 1
        completed.append(seed)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] Simulation for {} wind at {} m/s with seed ID {} is'
              ' terminated at {}:{}. {} tasks waiting to be completed ...'
              .format(pos,length, seed[0], seed[1], seed[2], hour,minute, rest))
    # begin multiprocessing
    pool = multiprocessing.Pool()
    [pool.apply_async(get_DLC11, args=(seed, outputFolder, silence, echo),
     callback=printer, error_callback=utils.handle_error) for seed in list_seed]
    pool.close()
    pool.join()

def get_DLC23(gridloss, outputFolder='', silence=False, echo=False):
    temp = DLC23(gridloss=gridloss, outputFolder=outputFolder, echo=echo)
    temp.run(silence=silence)
    return gridloss

def get_DLC23_multiprocess(list_gridloss, outputFolder='', silence=False,
                           echo=False):
    print('DLC v0.3 (November 20 2018)')
    print('========== Multiprocessing Mode ==========')
    # prepare a callback function
    length = len(list_gridloss)
    completed = []
    def printer(gridloss):
        pos = list_gridloss.index(gridloss) + 1
        completed.append(gridloss)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] Simulation for {} wind at {} with gridloss on {} s is'
              ' terminated at {}:{}. {} tasks waiting to be completed ...'
              .format(pos, length, gridloss[0], gridloss[1], gridloss[2], hour,
              minute, rest))
    # begin multiprocessing
    pool = multiprocessing.Pool()
    [pool.apply_async(get_DLC23, args=(gridloss, outputFolder, silence, echo),
     callback=printer, error_callback=utils.handle_error) for gridloss in list_gridloss]
    pool.close()
    pool.join()

#!------------------------------------------------------------------------------
#!                                    MAIN FUNCTION
#!------------------------------------------------------------------------------
@utils.timer
def main():
    # Load seeds
    with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'):
        with open('6seeds.json', 'r') as f:
            seeds = json.loads(f.read())

    liste = []
    [liste.append(s) for s in seeds if s[0] == "NTM"]
    seeds = liste[:1]

    # ----- Running on single processor
    # get_DLC11(seeds[0])
    # get_DLC11(['NTM','13','-1491944232'], silence=False)
    # get_DLC23(['EOG', 'R', '77.7'])

    # Test a case that will produce error during FAST calculation
    # get_DLC11(['NTM','3','1480621087'], silence=1)

    # ----- Running on multi processor
    get_DLC23_multiprocess([['EOG', 'R', '77.6'], ['EOG', 'R', '77.8']], silence=1)


#!------------------------------------------------------------------------------
#!                                     RUNNING TEST
#!------------------------------------------------------------------------------
if __name__ == '__main__':
        main()
