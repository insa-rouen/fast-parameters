#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DLC
#
# Authors: Hao BAI (hao.bai@insa-rouen.fr)
# Version: 0.0
# Date: 28/10/2018
#
# Comments:
#     - 0.0: Create a general class for preparing FAST input scripts
#     - 0.1: Add DLC11 class designed for DLC1.1
#     
# Description:
#     Prepare a general class for DLC input scripts
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#-----------------------------------------------------------------------------------------
#                                        MODULES
#-----------------------------------------------------------------------------------------
#============================== Modules Personnels ==============================
from tools import utils
import sys, IPython # to colorize traceback errors in terminal
sys.excepthook = IPython.core.ultratb.ColorTB()
#============================== Modules Communs ==============================
import re
import os
import json
import platform
import fileinput # iterate over lines from multiple input files
import shutil # high-level file operations
import subprocess # call a bash command e.g. 'ls'
import multiprocessing # enable multiprocessing



#-----------------------------------------------------------------------------------------
#                                    CLASS DEFINITION
#-----------------------------------------------------------------------------------------
class DLC(object):
    ''' Customize FAST input scripts for DLC
        *ATTRIBUTES*
    '''
    def __init__(self, seed, case, outputFolder, echo):
        self.seed =  seed
        self.case = case
        self.outputFolder = outputFolder
        self.echo = echo
        # Get OS platform name
        self._system = {'Linux':'FAST_glin64', 'Darwin':'FAST_gdar64'}
        self._fastName = self._system.get(platform.system())
        # some fixed path
        self.outputPath = os.path.expanduser(
                            '~/Eolien/Parameters/Python/{0}/Output/{0}'.format(self.case))
        self.inputPath = os.path.expanduser('~/Eolien/Parameters/Python/{}'.format(
                                                                               self.case))
        self.prefix = '/{}'.format(self.case)
        self.fastFile = '{}_{}_{}mps.fst'.format(self.prefix, self.seed[0], self.seed[1])
        self.inflowFile='{}_{}_{}mps.IW.dat'.format(self.prefix,self.seed[0],self.seed[1])
        self.servoFile = ''


    def _change_wind_profil(self):
        # InflowWind input script --------------------------------------------------------
        with open(self.inputPath+self.inflowFile, 'r') as f:
            data = f.read()
            data = self._change_string(data, 'Filename')

        filename = '{}_{}_{}mps_{}.IW.dat'.format(self.prefix, self.seed[0], self.seed[1], 
                                                 self.seed[2])
        with open(self.inputPath+filename, 'w') as f:
            f.write(data)
        self.inflowFile = filename # update Inflow .dat file

        # FAST input script --------------------------------------------------------------
        with open(self.inputPath+self.fastFile, 'r') as f:
            data = f.read()
            data = self._change_string(data, 'InflowFile')
        
        filename = '{}_{}_{}mps_{}.fst'.format(self.prefix, self.seed[0], self.seed[1],
                                              self.seed[2])
        with open(self.inputPath+filename, 'w') as f:
            f.write(data)
        self.fastFile = filename # update .fst file

    def _change_string(self, text, keyword):
        if keyword == 'Filename':
            old = "{}/{}_{}mps.bts".format(self.case, self.seed[0], self.seed[1])
            new = "{}/{}_{}mps_{}.bts".format(self.case, self.seed[0], self.seed[1],
                                              self.seed[2])
            text = re.sub(old, new ,text)

        if keyword == 'InflowFile':
            old = "{}_{}_{}mps.IW.dat".format(self.case, self.seed[0], self.seed[1])
            new = "{}_{}_{}mps_{}.IW.dat".format(self.case, self.seed[0], self.seed[1],
                                                 self.seed[2])
            text = re.sub(old, new ,text)
        return text

    def _fast(self, silence):
        ''' Call FAST program
        '''
        with utils.cd('~/Eolien/FAST'):
            command = './{0} {1}{2}'.format(self._fastName, self.inputPath, self.fastFile)
            try:
                if silence:
                    output = subprocess.check_output([command], shell=True)
                else:
                    output = subprocess.check_call([command], shell=True)
                    # Note:
                    # When shell=False, args[:] is a command line to execute
                    # When shell=True, args[0] is a command line to execute and args[1:] 
                    # is arguments to sh
            except subprocess.CalledProcessError as error:
                errorMessage = error.output
                debug = True
            except Exception as e:
                raise e
            else:
                debug = False
        # if an error occurs during execution, write output message to file
        if debug:
            directory = self.inputPath + '/log'
            if not os.path.exists(directory): # create new folder if non-exist
                os.makedirs(directory)
            with open(directory+'/'+self.seed[2]+'.bug', 'wb') as f:
                f.write(errorMessage)
            print("|- [ERROR] FAST has an error for simulation {},".format(self.seed),
                  "please see report in {}".format(directory))

    def _move(self):
        ''' Move and rename FAST output file (.out) to output folder
        '''
        source = self.inputPath+'{}_{}_{}mps_{}.out'.format(self.prefix, self.seed[0],
                                                           self.seed[1], self.seed[2])
        destination = self.outputPath+self.outputFolder+'{}_{}mps_{}.out'.format(
                                                 self.seed[0], self.seed[1], self.seed[2])
        shutil.move(source, destination)


class DLC11(DLC):
    ''' DLC1.1 NTM
        Mean wind speed: Vcut-in <= Vhub <= Vcut-out
        *ATTRIBUTES*
    '''
    def __init__(self, seed, case='DLC1.1', outputFolder='/', echo=False):
        super(DLC11, self).__init__(seed, case, outputFolder, echo)
        
    def run(self, silence=False):
        print("|- Calculating {} at {} m/s with seed ID {} ...".format(self.seed[0],
                                                              self.seed[1], self.seed[2]))
        self._change_wind_profil()
        self._fast(silence)
        self._move()



#-----------------------------------------------------------------------------------------
#                                  FUNCTION DEFINITION
#-----------------------------------------------------------------------------------------
def get_DLC11(seed, outputFolder='/', silence=False, echo=False):
    temp = DLC11(seed=seed, outputFolder=outputFolder, echo=echo)
    temp.run(silence=silence)

def get_DLC11_multiprocess(list_seed, outputFolder='/', silence=False, echo=False):
    pool = multiprocessing.Pool()
    [pool.apply_async(get_DLC11, args=(seed, outputFolder, silence, echo),
     error_callback=utils.handle_error) for seed in list_seed]
    pool.close()
    pool.join()



#-----------------------------------------------------------------------------------------
#                                     MAIN FUNCTION
#-----------------------------------------------------------------------------------------
@utils.timer
def main():
    # Load seeds
    with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'):
        with open('6seeds.json', 'r') as f:
            seeds = json.loads(f.read())

    liste = []
    [liste.append(s) for s in seeds if s[0] == "NTM"]
    seeds = liste[:1]

    # ----- Running on single processor
    get_DLC11(seeds)



#-----------------------------------------------------------------------------------------
#                                      RUNNING TEST
#-----------------------------------------------------------------------------------------
if __name__ == '__main__':
        main()
